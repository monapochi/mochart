{
  "version": 3,
  "sources": ["../src/renderer/canvas/canvasRenderer.ts", "../src/renderer/webgl2/webgl2Renderer.ts", "../src/renderer/webgpu/webgpuRenderer.ts", "../src/core/indicators.ts", "../src/core/indicatorTypes.ts", "../src/indicators/phase1.ts", "../src/indicators/phase2.ts", "../src/indicators/phase3.ts", "../src/indicators/phase4.ts", "../src/core/tradeMarkers.ts", "../src/core/chart.ts", "../src/core/embedApi.ts", "../src/index.ts", "../src/core/i18n.ts", "../src/core/indicatorCatalog.ts"],
  "sourcesContent": [
    "export class CanvasRenderer {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this.canvas = canvas;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new Error('2D context not available');\n    this.ctx = ctx;\n    this.resize();\n  }\n\n  resize() {\n    const dpr = window.devicePixelRatio || 1;\n    const w = this.canvas.clientWidth || this.canvas.width || 800;\n    const h = this.canvas.clientHeight || this.canvas.height || 600;\n    this.canvas.width = Math.floor(w * dpr);\n    this.canvas.height = Math.floor(h * dpr);\n    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n\n  clear() {\n    const w = this.canvas.width / (window.devicePixelRatio || 1);\n    const h = this.canvas.height / (window.devicePixelRatio || 1);\n    this.ctx.clearRect(0, 0, w, h);\n  }\n\n  private niceStep(range: number, targetTicks: number) {\n    const raw = range / targetTicks;\n    const pow = Math.pow(10, Math.floor(Math.log10(raw)));\n    const r = raw / pow;\n    const nice = r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10;\n    return nice * pow;\n  }\n\n  private formatPrice(v: number) {\n    const abs = Math.abs(v);\n    const digits = abs < 1 ? 4 : abs < 10 ? 3 : abs < 100 ? 2 : 2;\n    return v.toLocaleString(undefined, { maximumFractionDigits: digits });\n  }\n\n  drawSeries(seriesId: string, data: Array<any>, options?: {\n    outlineColor?: string;\n    wickColor?: string;\n    upColor?: string;\n    downColor?: string;\n    background?: string;\n    font?: string;\n    gridColor?: string;\n    axisLabelColor?: string;\n    yAxisGutterPx?: number;\n    xAxisHeightPx?: number;\n    paddingRatio?: number;\n    minPaddingPx?: number;\n    maxVisibleBars?: number;\n    startIndex?: number;\n    visibleCount?: number;\n    targetXTicks?: number;\n    targetYTicks?: number;\n  }) {\n    if (!data || data.length === 0) return;\n    // prepare canvas\n    const dpr = window.devicePixelRatio || 1;\n    const w = this.canvas.clientWidth || 800;\n    const h = this.canvas.clientHeight || 600;\n    this.canvas.width = Math.floor(w * dpr);\n    this.canvas.height = Math.floor(h * dpr);\n    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\n    // layout\n    const gutterLeft = options?.yAxisGutterPx ?? 56;\n    const gutterRight = 8;\n    const gutterTop = 8;\n    const xAxisHeight = options?.xAxisHeightPx ?? 26;\n    const plotX = gutterLeft;\n    const plotY = gutterTop;\n    const plotW = w - gutterLeft - gutterRight;\n    const plotH = h - gutterTop - xAxisHeight - 6;\n\n    // visible window: allow override via options.startIndex/options.visibleCount\n    const defaultMaxVisible = options?.maxVisibleBars ?? 200;\n    const visibleCount = Math.min(options?.visibleCount ?? defaultMaxVisible, data.length);\n    let start = typeof options?.startIndex === 'number' ? options!.startIndex : Math.max(0, data.length - visibleCount);\n    if (start < 0) start = 0;\n    if (start + visibleCount > data.length) start = Math.max(0, data.length - visibleCount);\n    const visible = data.slice(start, Math.min(data.length, start + visibleCount));\n\n    // compute visible price range\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    for (const d of visible) { if (d.low < min) min = d.low; if (d.high > max) max = d.high; }\n    if (!isFinite(min) || !isFinite(max)) return;\n    const padRatio = options?.paddingRatio ?? 0.05;\n    const pad = (max - min) * padRatio;\n    const yMin = min - Math.max(pad, options?.minPaddingPx ?? 6);\n    const yMax = max + Math.max(pad, options?.minPaddingPx ?? 6);\n\n    const priceToY = (p: number) => {\n      const t = (p - yMin) / (yMax - yMin || 1);\n      return plotY + (1 - t) * plotH;\n    };\n\n    // clear background\n    this.ctx.fillStyle = options?.background ?? '#ffffff';\n    this.ctx.fillRect(0, 0, w, h);\n\n    // Y ticks (nice numbers)\n    const targetYTicks = options?.targetYTicks ?? 5;\n    const step = this.niceStep(yMax - yMin, targetYTicks);\n    const firstTick = Math.ceil(yMin / step) * step;\n    const ticks: number[] = [];\n    for (let v = firstTick; v <= yMax + 1e-12; v += step) ticks.push(v);\n\n    // draw grid and Y labels\n    this.ctx.font = options?.font ?? '12px sans-serif';\n    this.ctx.textAlign = 'right';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillStyle = options?.axisLabelColor ?? '#222222';\n    this.ctx.strokeStyle = options?.gridColor ?? '#e6e6e6';\n    this.ctx.lineWidth = 1;\n    for (const t of ticks) {\n      const y = priceToY(t);\n      // grid\n      this.ctx.beginPath();\n      this.ctx.moveTo(plotX, y);\n      this.ctx.lineTo(plotX + plotW, y);\n      this.ctx.stroke();\n      // label\n      this.ctx.fillStyle = options?.axisLabelColor ?? '#222222';\n      this.ctx.fillText(this.formatPrice(t), plotX - 8, y);\n    }\n\n    // draw Y axis line\n    this.ctx.strokeStyle = options?.axisLabelColor ?? '#222222';\n    this.ctx.beginPath(); this.ctx.moveTo(plotX, plotY); this.ctx.lineTo(plotX, plotY + plotH); this.ctx.stroke();\n\n    // X ticks: choose approx targetXTicks\n    const targetXTicks = options?.targetXTicks ?? 6;\n    const visibleFromTime = visible[0].time;\n    const visibleToTime = visible[visible.length - 1].time;\n    const spanMs = visibleToTime - visibleFromTime || 1;\n    // simple strategy: pick evenly spaced indices\n    const xTicks: Array<{time:number, idx:number}> = [];\n    for (let i = 0; i < targetXTicks; i++) {\n      const frac = i / (targetXTicks - 1);\n      const idx = Math.round(frac * (visible.length - 1));\n      xTicks.push({ time: visible[idx].time, idx: start + idx });\n    }\n\n    // draw candles\n    const stepX = plotW / Math.max(1, visible.length - 1);\n    const candleW = Math.max(2, Math.min(Math.floor(stepX * 0.7), 40));\n    const outlineColor = options?.outlineColor || '#222222';\n    const wickColor = options?.wickColor || outlineColor;\n    const upColor = options?.upColor || '#2e7d32';\n    const downColor = options?.downColor || '#d32f2f';\n\n    // clip to plot area\n    this.ctx.save();\n    this.ctx.beginPath();\n    this.ctx.rect(plotX, plotY, plotW, plotH);\n    this.ctx.clip();\n\n    for (let i = 0; i < visible.length; i++) {\n      const d = visible[i];\n      const x = plotX + i * stepX;\n      const yOpen = priceToY(d.open);\n      const yClose = priceToY(d.close);\n      const yHigh = priceToY(d.high);\n      const yLow = priceToY(d.low);\n      const top = Math.min(yOpen, yClose);\n      const bottom = Math.max(yOpen, yClose);\n\n      // wick\n      this.ctx.strokeStyle = wickColor; this.ctx.lineWidth = 1;\n      this.ctx.beginPath(); this.ctx.moveTo(x + 0.5, yHigh); this.ctx.lineTo(x + 0.5, yLow); this.ctx.stroke();\n\n      // body\n      if (d.close > d.open) {\n        this.ctx.fillStyle = upColor;\n        this.ctx.fillRect(x - candleW/2, top, candleW, Math.max(1, bottom - top));\n        this.ctx.strokeStyle = outlineColor; this.ctx.lineWidth = 1; this.ctx.strokeRect(x - candleW/2, top, candleW, Math.max(1, bottom - top));\n      } else if (d.close < d.open) {\n        this.ctx.fillStyle = downColor;\n        this.ctx.fillRect(x - candleW/2, top, candleW, Math.max(1, bottom - top));\n        this.ctx.strokeStyle = outlineColor; this.ctx.lineWidth = 1; this.ctx.strokeRect(x - candleW/2, top, candleW, Math.max(1, bottom - top));\n      } else {\n        // equal -> crosshair\n        const cy = (yOpen + yClose) / 2;\n        const hx = candleW * 0.9;\n        this.ctx.strokeStyle = outlineColor; this.ctx.lineWidth = 1.5;\n        this.ctx.beginPath(); this.ctx.moveTo(x - hx/2, cy); this.ctx.lineTo(x + hx/2, cy); this.ctx.moveTo(x, cy - hx/2); this.ctx.lineTo(x, cy + hx/2); this.ctx.stroke();\n      }\n    }\n    this.ctx.restore();\n\n    // draw X axis ticks and labels\n    const dateFormat = (t: number) => {\n      const dt = new Date(t);\n      if (spanMs > 365 * 24 * 3600 * 1000) return dt.toLocaleDateString();\n      if (spanMs > 7 * 24 * 3600 * 1000) return dt.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });\n      return dt.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });\n    };\n\n    this.ctx.fillStyle = options?.axisLabelColor ?? '#222222';\n    this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'top'; this.ctx.font = options?.font ?? '12px sans-serif';\n    for (const t of xTicks) {\n      const localIdx = t.idx - start;\n      const x = plotX + localIdx * stepX;\n      // tick\n      this.ctx.beginPath(); this.ctx.moveTo(x + 0.5, plotY + plotH); this.ctx.lineTo(x + 0.5, plotY + plotH + 6); this.ctx.stroke();\n      // label\n      this.ctx.fillText(dateFormat(t.time), x, plotY + plotH + 4 + 2);\n    }\n\n    // draw X axis baseline\n    this.ctx.strokeStyle = options?.axisLabelColor ?? '#222222';\n    this.ctx.beginPath(); this.ctx.moveTo(plotX, plotY + plotH); this.ctx.lineTo(plotX + plotW, plotY + plotH); this.ctx.stroke();\n  }\n\n  getLayout(data: Array<any>, options?: { yAxisGutterPx?: number; xAxisHeightPx?: number; maxVisibleBars?: number; startIndex?: number; visibleCount?: number; paddingRatio?: number; minPaddingPx?: number }) {\n    const w = this.canvas.clientWidth || 800;\n    const h = this.canvas.clientHeight || 600;\n    const gutterLeft = options?.yAxisGutterPx ?? 56;\n    const gutterRight = 8;\n    const gutterTop = 8;\n    const xAxisHeight = options?.xAxisHeightPx ?? 26;\n    const plotX = gutterLeft;\n    const plotY = gutterTop;\n    const plotW = w - gutterLeft - gutterRight;\n    const plotH = h - gutterTop - xAxisHeight - 6;\n\n    const defaultMaxVisible = options?.maxVisibleBars ?? 200;\n    const visibleCount = Math.min(options?.visibleCount ?? defaultMaxVisible, data.length);\n    let start = typeof options?.startIndex === 'number' ? options!.startIndex : Math.max(0, data.length - visibleCount);\n    if (start < 0) start = 0;\n    if (start + visibleCount > data.length) start = Math.max(0, data.length - visibleCount);\n    const visible = data.slice(start, Math.min(data.length, start + visibleCount));\n\n    // compute visible price range\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    for (const d of visible) { if (d.low < min) min = d.low; if (d.high > max) max = d.high; }\n    const padRatio = options?.paddingRatio ?? 0.05;\n    const pad = (max - min) * padRatio;\n    const yMin = min - Math.max(pad, options?.minPaddingPx ?? 6);\n    const yMax = max + Math.max(pad, options?.minPaddingPx ?? 6);\n\n    const stepX = plotW / Math.max(1, visible.length - 1);\n    const candleW = Math.max(2, Math.min(Math.floor(stepX * 0.7), 40));\n\n    return { plotX, plotY, plotW, plotH, gutterLeft, gutterTop, xAxisHeight, startIndex: start, visibleCount: visible.length, stepX, candleW, yMin, yMax };\n  }\n\n  mapClientToData(clientX: number, clientY: number, data: Array<any>, options?: { yAxisGutterPx?: number; xAxisHeightPx?: number; maxVisibleBars?: number; startIndex?: number; visibleCount?: number; paddingRatio?: number; minPaddingPx?: number }) {\n    const layout = this.getLayout(data, options);\n    const { plotX, plotY, plotW, plotH, startIndex, visibleCount, stepX, yMin, yMax } = layout;\n    const localX = clientX - plotX;\n    const localY = clientY - plotY;\n    if (localX < -10 || localX > plotW + 10 || localY < -10 || localY > plotH + 10) return null;\n    const idxFloat = localX / stepX;\n    const idx = Math.round(idxFloat);\n    const clamped = Math.max(0, Math.min(visibleCount - 1, idx));\n    const dataIdx = startIndex + clamped;\n    const point = data[dataIdx];\n    if (!point) return null;\n    const x = plotX + clamped * stepX;\n    const priceAtY = yMin + (1 - (localY / plotH)) * (yMax - yMin || 0);\n    return { index: dataIdx, localIndex: clamped, time: point.time, point, x, y: plotY + localY, priceAtY };\n  }\n\n  drawCrosshairAt(clientX: number, clientY: number, data: Array<any>, options?: { color?: string; lineWidth?: number; yAxisGutterPx?: number; xAxisHeightPx?: number; maxVisibleBars?: number; startIndex?: number; visibleCount?: number }) {\n    const layout = this.getLayout(data, options);\n    const { plotX, plotY, plotW, plotH, startIndex, visibleCount, stepX } = layout;\n    const mapped = this.mapClientToData(clientX, clientY, data, options);\n    if (!mapped) return;\n    const x = mapped.x;\n    const priceY = (() => {\n      const { yMin, yMax } = layout as any;\n      const p = mapped.point.close;\n      const t = (p - yMin) / (yMax - yMin || 1);\n      return plotY + (1 - t) * plotH;\n    })();\n\n    this.ctx.save();\n    this.ctx.strokeStyle = options?.color ?? '#666666';\n    this.ctx.lineWidth = options?.lineWidth ?? 1;\n    // vertical\n    this.ctx.beginPath(); this.ctx.moveTo(x + 0.5, plotY); this.ctx.lineTo(x + 0.5, plotY + plotH); this.ctx.stroke();\n    // horizontal at price\n    this.ctx.beginPath(); this.ctx.moveTo(plotX, priceY + 0.5); this.ctx.lineTo(plotX + plotW, priceY + 0.5); this.ctx.stroke();\n    // small circle at candle center\n    this.ctx.fillStyle = options?.color ?? '#666666';\n    this.ctx.beginPath(); this.ctx.arc(x, priceY, 3, 0, Math.PI * 2); this.ctx.fill();\n    this.ctx.restore();\n  }\n\n  updateBuffers(_seriesId: string, _data: Float32Array, _offset?: number) {\n    // no-op for canvas renderer\n  }\n\n  partialUpdateBuffers(_seriesId: string, _patches: Array<{offset:number; data:Float32Array}>) {\n    // no-op\n  }\n\n  destroy() {\n    // nothing to clean up\n  }\n}\n",
    "import type { ChartConfig, ChartColors, OhlcvPoint } from '../../core/types';\nimport type { ChartRenderer } from '../renderer';\n\nconst DEFAULT_COLORS: ChartColors = {\n  up: [0.0, 0.7, 0.0, 1.0],\n  down: [1.0, 0.0, 0.0, 1.0],\n  wick: [0.0, 0.0, 0.0, 1.0],\n  outline: [0.0, 0.0, 0.0, 1.0],\n  background: [1.0, 1.0, 1.0, 1.0],\n};\n\nexport class WebGL2Renderer implements ChartRenderer {\n  private gl!: WebGL2RenderingContext;\n  private program!: WebGLProgram;\n  private buffer!: WebGLBuffer;\n  private data: OhlcvPoint[] = [];\n  private config: ChartConfig = {};\n  private colors: ChartColors = DEFAULT_COLORS;\n\n  private aCoordinates = -1;\n  private uTranslation: WebGLUniformLocation | null = null;\n  private uScale: WebGLUniformLocation | null = null;\n  private uResolution: WebGLUniformLocation | null = null;\n  private uColor: WebGLUniformLocation | null = null;\n\n  initialize(canvas: HTMLCanvasElement): void {\n    const gl = canvas.getContext('webgl2');\n    if (!gl) {\n      throw new Error('WebGL2 is not supported in this environment.');\n    }\n\n    this.gl = gl;\n    this.program = this.createProgram(gl, VERTEX_SHADER, FRAGMENT_SHADER);\n    this.buffer = this.createBuffer(gl);\n\n    this.aCoordinates = gl.getAttribLocation(this.program, 'a_coordinates');\n    this.uTranslation = gl.getUniformLocation(this.program, 'u_translation');\n    this.uScale = gl.getUniformLocation(this.program, 'u_scale');\n    this.uResolution = gl.getUniformLocation(this.program, 'u_resolution');\n    this.uColor = gl.getUniformLocation(this.program, 'u_color');\n\n    gl.useProgram(this.program);\n  }\n\n  setData(data: OhlcvPoint[]): void {\n    this.data = data;\n    this.uploadData();\n  }\n\n  setConfig(config: ChartConfig): void {\n    this.config = config;\n    this.colors = {\n      ...DEFAULT_COLORS,\n      ...(config.colors ?? {}),\n    };\n  }\n\n  setIndicatorSegments(_segments: Float32Array): void {\n    // TODO: WebGL2 indicator rendering\n  }\n\n  render(): void {\n    const gl = this.gl;\n    if (!gl || !this.program || !this.buffer) return;\n\n    this.resize();\n\n    gl.clearColor(...this.colors.background);\n    gl.clearDepth(1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    gl.useProgram(this.program);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n    gl.enableVertexAttribArray(this.aCoordinates);\n    gl.vertexAttribPointer(this.aCoordinates, 3, gl.FLOAT, false, 0, 0);\n\n    if (this.uScale) gl.uniform2fv(this.uScale, new Float32Array([0.23, 5.0]));\n    if (this.uResolution) gl.uniform2fv(this.uResolution, new Float32Array([gl.drawingBufferWidth, gl.drawingBufferHeight]));\n\n    const stride = 6;\n\n    for (let c = 0; c < this.data.length; c++) {\n      if (this.uTranslation) gl.uniform2fv(this.uTranslation, new Float32Array([(c + 1) * 25, 0]));\n\n      if (this.uColor) gl.uniform4fv(this.uColor, new Float32Array(this.colors.wick));\n      gl.lineWidth(1);\n      gl.drawArrays(gl.LINES, c * stride + 4, 2);\n\n      const isUp = this.data[c].open < this.data[c].close;\n      if (this.uColor) gl.uniform4fv(this.uColor, new Float32Array(isUp ? this.colors.up : this.colors.down));\n      gl.drawArrays(gl.TRIANGLE_FAN, c * stride, 4);\n\n      if (this.uColor) gl.uniform4fv(this.uColor, new Float32Array(this.colors.outline));\n      gl.drawArrays(gl.LINE_LOOP, c * stride, 4);\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  }\n\n  resize(): void {\n    const canvas = this.gl.canvas as HTMLCanvasElement;\n    if (canvas.clientWidth !== canvas.width) canvas.width = canvas.clientWidth;\n    if (canvas.clientHeight !== canvas.height) canvas.height = canvas.clientHeight;\n  }\n\n  destroy(): void {\n    const gl = this.gl;\n    if (this.program) gl.deleteProgram(this.program);\n    if (this.buffer) gl.deleteBuffer(this.buffer);\n  }\n\n  private uploadData(): void {\n    const gl = this.gl;\n    const vertices = this.createVertices(this.data);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  }\n\n  private createVertices(data: OhlcvPoint[]): number[] {\n    return data\n      .map((d) => [\n        -19, d.open, 0,\n        21, d.open, 0,\n        21, d.close, 0,\n        -19, d.close, 0,\n        1, d.high, 0,\n        1, d.low, 0,\n      ])\n      .reduce((a, b) => a.concat(b), [] as number[]);\n  }\n\n  private createBuffer(gl: WebGL2RenderingContext): WebGLBuffer {\n    const buffer = gl.createBuffer();\n    if (!buffer) {\n      throw new Error('Failed to create WebGL buffer.');\n    }\n    return buffer;\n  }\n\n  private createProgram(gl: WebGL2RenderingContext, vs: string, fs: string): WebGLProgram {\n    const vertexShader = this.compileShader(gl, gl.VERTEX_SHADER, vs);\n    const fragmentShader = this.compileShader(gl, gl.FRAGMENT_SHADER, fs);\n\n    const program = gl.createProgram();\n    if (!program) throw new Error('Failed to create WebGL program.');\n\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      const info = gl.getProgramInfoLog(program);\n      gl.deleteProgram(program);\n      throw new Error(`Program link failed: ${info ?? 'unknown error'}`);\n    }\n\n    return program;\n  }\n\n  private compileShader(gl: WebGL2RenderingContext, type: number, source: string): WebGLShader {\n    const shader = gl.createShader(type);\n    if (!shader) throw new Error('Failed to create shader.');\n\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      const info = gl.getShaderInfoLog(shader);\n      gl.deleteShader(shader);\n      throw new Error(`Shader compile failed: ${info ?? 'unknown error'}`);\n    }\n\n    return shader;\n  }\n}\n\nconst VERTEX_SHADER = `#version 300 es\nin vec3 a_coordinates;\nuniform vec2 u_translation;\nuniform vec2 u_scale;\nuniform vec2 u_resolution;\n\nvoid main() {\n  vec2 pos = (a_coordinates.xy * u_scale + u_translation + vec2(0.5, 0.5)) / u_resolution;\n  pos.x = pos.x - 1.0;\n  gl_Position = vec4(pos, a_coordinates.z, 1.0);\n}\n`;\n\nconst FRAGMENT_SHADER = `#version 300 es\nprecision mediump float;\nuniform vec4 u_color;\nout vec4 outColor;\n\nvoid main() {\n  outColor = u_color;\n}\n`;\n",
    "// WebGPU renderer interface skeleton. Concrete implementation to follow.\nexport interface WebGPUBackend {\n  init(canvas: HTMLCanvasElement): Promise<void>;\n  drawSeries(seriesId: string, data: Float32Array): void;\n  updateBuffers(seriesId: string, data: Float32Array, offset?: number): void;\n  partialUpdateBuffers(seriesId: string, patches: Array<{offset:number; data:Float32Array}>): void;\n  resizeViewport(width: number, height: number): void;\n  destroy(): void;\n}\n\nexport class WebGPUStub implements WebGPUBackend {\n  private device: GPUDevice | null = null;\n  private context: GPUCanvasContext | null = null;\n\n  async init(canvas: HTMLCanvasElement): Promise<void> {\n    // Try to initialize WebGPU; graceful fallback if unavailable\n    if (!('gpu' in navigator)) {\n      console.warn('WebGPU not supported in this environment');\n      return;\n    }\n    try {\n      const adapter = await (navigator as any).gpu.requestAdapter();\n      if (!adapter) { console.warn('No GPU adapter found'); return; }\n      const device = await adapter.requestDevice();\n      this.device = device;\n      this.context = (canvas.getContext('webgpu') as unknown) as GPUCanvasContext;\n      // Configure basic swapChain format if available\n      const format = navigator.userAgent.includes('Firefox') ? 'bgra8unorm' : 'rgba8unorm';\n      try { this.context.configure({ device, format }); } catch (e) { /* ignore if unsupported */ }\n      console.info('WebGPU initialized');\n    } catch (e) {\n      console.warn('WebGPU initialization failed', e);\n    }\n  }\n\n  drawSeries(_seriesId: string, _data: Float32Array): void { /* to be implemented */ }\n  updateBuffers(_seriesId: string, _data: Float32Array, _offset?: number): void { /* to be implemented */ }\n  partialUpdateBuffers(_seriesId: string, _patches: Array<{offset:number; data:Float32Array}>): void { /* to be implemented */ }\n  resizeViewport(_width: number, _height: number): void { /* to be implemented */ }\n  destroy(): void {\n    if (this.device) { /* device cleanup if needed */ }\n    this.device = null;\n    this.context = null;\n  }\n}\n\nimport type { ChartConfig, ChartColors, OhlcvPoint } from '../../core/types';\nimport type { ChartRenderer } from '../renderer';\n\ntype GPUAdapter = unknown;\ntype GPUDevice = {\n  queue: { submit: (commands: unknown[]) => void; writeBuffer?: (buffer: any, offset: number, data: ArrayBufferView) => void };\n  createCommandEncoder: () => any;\n  createRenderPipeline: (descriptor: any) => any;\n  createShaderModule: (descriptor: any) => any;\n  createBuffer: (descriptor: any) => any;\n  createComputePipeline: (descriptor: any) => any;\n  createBindGroup: (descriptor: any) => any;\n};\ntype GPUCanvasContext = { configure: (options: any) => void; getCurrentTexture: () => { createView: () => any } };\ntype GPUTextureFormat = string;\n\ntype WebGPUContext = {\n  adapter: GPUAdapter;\n  device: GPUDevice;\n  context: GPUCanvasContext;\n  format: GPUTextureFormat;\n};\n\nconst DEFAULT_COLORS: ChartColors = {\n  up: [0.0, 0.7, 0.0, 1.0],\n  down: [1.0, 0.0, 0.0, 1.0],\n  wick: [0.0, 0.0, 0.0, 1.0],\n  outline: [0.0, 0.0, 0.0, 1.0],\n  background: [1.0, 1.0, 1.0, 1.0],\n};\n\nexport class WebGPURenderer implements ChartRenderer {\n  private data: OhlcvPoint[] = [];\n  private config: ChartConfig = {};\n  private colors: ChartColors = DEFAULT_COLORS;\n  private context: WebGPUContext | null = null;\n  private canvas: HTMLCanvasElement | null = null;\n  private initPromise: Promise<void> | null = null;\n  private pipeline: any = null;\n  private vertexBuffer: any = null;\n  private vertexCount = 0;\n  private linePipeline: any = null;\n  private indicatorBuffer: any = null;\n  private indicatorCount = 0;\n  private indicatorBufferSize = 0;\n  private vertexBufferSize = 0;\n\n  initialize(canvas: HTMLCanvasElement): void {\n    if (!('gpu' in navigator)) {\n      throw new Error('WebGPU is not supported in this environment.');\n    }\n    this.canvas = canvas;\n    this.initPromise = this.initWebGPU();\n  }\n\n  setData(data: OhlcvPoint[]): void {\n    this.data = data;\n    this.buildGeometry();\n  }\n\n  setConfig(config: ChartConfig): void {\n    this.config = config;\n    this.colors = {\n      ...DEFAULT_COLORS,\n      ...(config.colors ?? {}),\n    };\n    this.buildGeometry();\n  }\n\n  setIndicatorSegments(segments: Float32Array): void {\n    if (!this.context) return;\n    const { device } = this.context;\n    this.indicatorCount = segments.length / 6;\n    if (this.indicatorCount === 0) {\n      this.indicatorBuffer = null;\n      this.indicatorBufferSize = 0;\n      return;\n    }\n    if (!this.indicatorBuffer || this.indicatorBufferSize !== segments.byteLength) {\n      this.indicatorBuffer = device.createBuffer({\n        size: segments.byteLength,\n        usage: (window as any).GPUBufferUsage.VERTEX | (window as any).GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n      });\n      new Float32Array(this.indicatorBuffer.getMappedRange()).set(segments);\n      this.indicatorBuffer.unmap();\n      this.indicatorBufferSize = segments.byteLength;\n    } else if (device.queue.writeBuffer) {\n      device.queue.writeBuffer(this.indicatorBuffer, 0, segments);\n    }\n  }\n\n  render(): void {\n    if (!this.context) return;\n    const { device, context: gpuContext } = this.context;\n\n    this.resize();\n\n    if (!this.pipeline || !this.vertexBuffer || this.vertexCount === 0) {\n      return;\n    }\n\n    const encoder = device.createCommandEncoder();\n    const textureView = gpuContext.getCurrentTexture().createView();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: textureView,\n          loadOp: 'clear',\n          storeOp: 'store',\n          clearValue: {\n            r: this.colors.background[0],\n            g: this.colors.background[1],\n            b: this.colors.background[2],\n            a: this.colors.background[3],\n          },\n        },\n      ],\n    });\n\n    pass.setPipeline(this.pipeline);\n    pass.setVertexBuffer(0, this.vertexBuffer);\n    pass.draw(this.vertexCount, 1, 0, 0);\n\n    if (this.linePipeline && this.indicatorBuffer && this.indicatorCount > 0) {\n      pass.setPipeline(this.linePipeline);\n      pass.setVertexBuffer(0, this.indicatorBuffer);\n      pass.draw(this.indicatorCount, 1, 0, 0);\n    }\n    pass.end();\n    device.queue.submit([encoder.finish()]);\n  }\n\n  resize(): void {\n    if (!this.context || !this.canvas) return;\n    const { device, context: gpuContext, format } = this.context;\n    const dpr = window.devicePixelRatio || 1;\n    const width = Math.max(1, Math.floor(this.canvas.clientWidth * dpr));\n    const height = Math.max(1, Math.floor(this.canvas.clientHeight * dpr));\n    if (this.canvas.width === width && this.canvas.height === height) return;\n    this.canvas.width = width;\n    this.canvas.height = height;\n    gpuContext.configure({ device, format, alphaMode: 'premultiplied' });\n  }\n\n  destroy(): void {\n    this.context = null;\n    this.canvas = null;\n    this.pipeline = null;\n    this.vertexBuffer = null;\n    this.vertexCount = 0;\n  }\n\n  private async initWebGPU(): Promise<void> {\n    if (!this.canvas) return;\n    const adapter = await (navigator as any).gpu.requestAdapter();\n    if (!adapter) {\n      throw new Error('WebGPU adapter not available.');\n    }\n    const device = await adapter.requestDevice();\n    const context = this.canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n    if (!context) {\n      throw new Error('Failed to acquire WebGPU canvas context.');\n    }\n    const format = (navigator as any).gpu.getPreferredCanvasFormat() as GPUTextureFormat;\n    context.configure({ device, format, alphaMode: 'premultiplied' });\n    this.context = { adapter, device, context, format };\n    this.pipeline = this.createPipeline(device, format);\n    this.linePipeline = this.createLinePipeline(device, format);\n    this.buildGeometry();\n  }\n\n  async computeIndicatorGPU(\n    wgslSource: string,\n    params: ArrayBuffer,\n    data: Float32Array,\n    outputLength: number\n  ): Promise<Float32Array | null> {\n    if (!this.context) return null;\n    const { device } = this.context;\n\n    const shader = device.createShaderModule({ code: wgslSource });\n    const pipeline = device.createComputePipeline({\n      layout: 'auto',\n      compute: { module: shader, entryPoint: 'main' },\n    });\n\n    const inputBuffer = device.createBuffer({\n      size: data.byteLength,\n      usage: (window as any).GPUBufferUsage.STORAGE | (window as any).GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n    new Float32Array(inputBuffer.getMappedRange()).set(data);\n    inputBuffer.unmap();\n\n    const uniformBuffer = device.createBuffer({\n      size: params.byteLength,\n      usage: (window as any).GPUBufferUsage.UNIFORM | (window as any).GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n    new Uint8Array(uniformBuffer.getMappedRange()).set(new Uint8Array(params));\n    uniformBuffer.unmap();\n\n    const outputBuffer = device.createBuffer({\n      size: outputLength * 4,\n      usage: (window as any).GPUBufferUsage.STORAGE | (window as any).GPUBufferUsage.COPY_SRC,\n    });\n    const readback = device.createBuffer({\n      size: outputLength * 4,\n      usage: (window as any).GPUBufferUsage.MAP_READ | (window as any).GPUBufferUsage.COPY_DST,\n    });\n\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: inputBuffer } },\n        { binding: 1, resource: { buffer: uniformBuffer } },\n        { binding: 2, resource: { buffer: outputBuffer } },\n      ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n\n    const workgroupSize = this.getWorkgroupSize(wgslSource);\n    const dataLen = data.length / 6;\n    const workgroupCount = Math.ceil(dataLen / workgroupSize);\n    pass.dispatchWorkgroups(workgroupCount);\n    pass.end();\n\n    encoder.copyBufferToBuffer(outputBuffer, 0, readback, 0, outputLength * 4);\n    device.queue.submit([encoder.finish()]);\n\n    await readback.mapAsync((window as any).GPUMapMode.READ);\n    const result = readback.getMappedRange();\n    const output = new Float32Array(result.slice(0));\n    readback.unmap();\n    return output;\n  }\n\n  createInputBuffer(data: Float32Array): any {\n    if (!this.context) return null;\n    const { device } = this.context;\n    const buffer = device.createBuffer({\n      size: data.byteLength,\n      usage: (window as any).GPUBufferUsage.STORAGE | (window as any).GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n    new Float32Array(buffer.getMappedRange()).set(data);\n    buffer.unmap();\n    return buffer;\n  }\n\n  updateInputBuffer(buffer: any, data: Float32Array): void {\n    if (!this.context || !buffer) return;\n    const { device } = this.context;\n    if (device.queue.writeBuffer) {\n      device.queue.writeBuffer(buffer, 0, data);\n    }\n  }\n\n  async computeIndicatorGPUWithInput(\n    wgslSource: string,\n    params: ArrayBuffer,\n    inputBuffer: any,\n    outputLength: number,\n    dataLen: number\n  ): Promise<Float32Array | null> {\n    if (!this.context || !inputBuffer) return null;\n    const { device } = this.context;\n\n    const shader = device.createShaderModule({ code: wgslSource });\n    const pipeline = device.createComputePipeline({\n      layout: 'auto',\n      compute: { module: shader, entryPoint: 'main' },\n    });\n\n    const uniformBuffer = device.createBuffer({\n      size: params.byteLength,\n      usage: (window as any).GPUBufferUsage.UNIFORM | (window as any).GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n    new Uint8Array(uniformBuffer.getMappedRange()).set(new Uint8Array(params));\n    uniformBuffer.unmap();\n\n    const outputBuffer = device.createBuffer({\n      size: outputLength * 4,\n      usage: (window as any).GPUBufferUsage.STORAGE | (window as any).GPUBufferUsage.COPY_SRC,\n    });\n    const readback = device.createBuffer({\n      size: outputLength * 4,\n      usage: (window as any).GPUBufferUsage.MAP_READ | (window as any).GPUBufferUsage.COPY_DST,\n    });\n\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: inputBuffer } },\n        { binding: 1, resource: { buffer: uniformBuffer } },\n        { binding: 2, resource: { buffer: outputBuffer } },\n      ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    const workgroupSize = this.getWorkgroupSize(wgslSource);\n    const workgroupCount = Math.ceil(dataLen / workgroupSize);\n    pass.dispatchWorkgroups(workgroupCount);\n    pass.end();\n    encoder.copyBufferToBuffer(outputBuffer, 0, readback, 0, outputLength * 4);\n    device.queue.submit([encoder.finish()]);\n\n    await readback.mapAsync((window as any).GPUMapMode.READ);\n    const result = readback.getMappedRange();\n    const output = new Float32Array(result.slice(0));\n    readback.unmap();\n    return output;\n  }\n\n  private getWorkgroupSize(wgslSource: string): number {\n    const match = wgslSource.match(/workgroup_size\\((\\d+)\\)/);\n    if (!match) return 256;\n    const value = Number(match[1]);\n    return Number.isFinite(value) && value > 0 ? value : 256;\n  }\n\n  private createPipeline(device: GPUDevice, format: GPUTextureFormat): any {\n    const shader = device.createShaderModule({\n      code: `\n        struct VSOut {\n          @builtin(position) position: vec4<f32>,\n          @location(0) color: vec4<f32>,\n        };\n\n        @vertex\n        fn vs_main(@location(0) pos: vec2<f32>, @location(1) color: vec4<f32>) -> VSOut {\n          var out: VSOut;\n          out.position = vec4<f32>(pos, 0.0, 1.0);\n          out.color = color;\n          return out;\n        }\n\n        @fragment\n        fn fs_main(@location(0) color: vec4<f32>) -> @location(0) vec4<f32> {\n          return color;\n        }\n      `,\n    });\n\n    return device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: shader,\n        entryPoint: 'vs_main',\n        buffers: [\n          {\n            arrayStride: 24,\n            attributes: [\n              { shaderLocation: 0, offset: 0, format: 'float32x2' },\n              { shaderLocation: 1, offset: 8, format: 'float32x4' },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: shader,\n        entryPoint: 'fs_main',\n        targets: [{ format }],\n      },\n      primitive: { topology: 'triangle-list' },\n    });\n  }\n\n  private createLinePipeline(device: GPUDevice, format: GPUTextureFormat): any {\n    const shader = device.createShaderModule({\n      code: `\n        struct VSOut {\n          @builtin(position) position: vec4<f32>,\n          @location(0) color: vec4<f32>,\n        };\n\n        @vertex\n        fn vs_main(@location(0) pos: vec2<f32>, @location(1) color: vec4<f32>) -> VSOut {\n          var out: VSOut;\n          out.position = vec4<f32>(pos, 0.0, 1.0);\n          out.color = color;\n          return out;\n        }\n\n        @fragment\n        fn fs_main(@location(0) color: vec4<f32>) -> @location(0) vec4<f32> {\n          return color;\n        }\n      `,\n    });\n\n    return device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: shader,\n        entryPoint: 'vs_main',\n        buffers: [\n          {\n            arrayStride: 24,\n            attributes: [\n              { shaderLocation: 0, offset: 0, format: 'float32x2' },\n              { shaderLocation: 1, offset: 8, format: 'float32x4' },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: shader,\n        entryPoint: 'fs_main',\n        targets: [{ format }],\n      },\n      primitive: { topology: 'line-list' },\n    });\n  }\n\n  private buildGeometry(): void {\n    if (!this.context || !this.data.length) return;\n\n    const { device } = this.context;\n    const count = this.data.length;\n    const minPrice = Math.min(...this.data.map((d) => d.low));\n    const maxPrice = Math.max(...this.data.map((d) => d.high));\n    const range = maxPrice - minPrice || 1;\n    const candleWidth = 2 / Math.max(1, count);\n    const wickWidth = candleWidth * 0.2;\n\n    // compensate for non-square canvas: scale X coordinates so candles keep correct aspect\n    const canvas = this.canvas as HTMLCanvasElement;\n    const aspectCorrection = canvas && canvas.width && canvas.height ? canvas.height / canvas.width : 1;\n\n    const vertices: number[] = [];\n    const colorUp = this.colors.up;\n    const colorDown = this.colors.down;\n    const colorWick = this.colors.wick;\n\n    const toX = (i: number) => (-1 + candleWidth * i + candleWidth * 0.5) * aspectCorrection;\n    const toY = (price: number) => ((price - minPrice) / range) * 2 - 1;\n\n    for (let i = 0; i < count; i++) {\n      const d = this.data[i];\n      const x = toX(i);\n      const bodyHalf = candleWidth * 0.4 * aspectCorrection;\n      const wickHalf = wickWidth * 0.5 * aspectCorrection;\n      const openY = toY(d.open);\n      const closeY = toY(d.close);\n      const highY = toY(d.high);\n      const lowY = toY(d.low);\n      const top = Math.max(openY, closeY);\n      const bottom = Math.min(openY, closeY);\n      const bodyColor = d.close >= d.open ? colorUp : colorDown;\n\n      // body quad (two triangles)\n      pushQuad(vertices, x - bodyHalf, bottom, x + bodyHalf, top, bodyColor);\n      // wick quad (thin)\n      pushQuad(vertices, x - wickHalf, lowY, x + wickHalf, highY, colorWick);\n    }\n\n    const data = new Float32Array(vertices);\n    this.vertexCount = data.length / 6;\n    if (!this.vertexBuffer || this.vertexBufferSize !== data.byteLength) {\n      this.vertexBuffer = device.createBuffer({\n        size: data.byteLength,\n        usage: (window as any).GPUBufferUsage.VERTEX | (window as any).GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n      });\n      new Float32Array(this.vertexBuffer.getMappedRange()).set(data);\n      this.vertexBuffer.unmap();\n      this.vertexBufferSize = data.byteLength;\n    } else if (device.queue.writeBuffer) {\n      device.queue.writeBuffer(this.vertexBuffer, 0, data);\n    }\n  }\n}\n\nconst pushQuad = (\n  out: number[],\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  color: [number, number, number, number]\n) => {\n  // tri 1\n  out.push(x0, y0, ...color);\n  out.push(x1, y0, ...color);\n  out.push(x1, y1, ...color);\n  // tri 2\n  out.push(x0, y0, ...color);\n  out.push(x1, y1, ...color);\n  out.push(x0, y1, ...color);\n};\n",
    "import type { IndicatorDefinition } from './indicatorTypes';\n\nexport interface IndicatorRegistry {\n  register(indicator: IndicatorDefinition<any, any>): void;\n  get(id: string): IndicatorDefinition | undefined;\n  listAll(): IndicatorDefinition[];\n  listByCategory(category: IndicatorDefinition['category']): IndicatorDefinition[];\n  listGPUEnabled(): IndicatorDefinition[];\n  resolveDependencies(ids: string[]): IndicatorDefinition[];\n}\n\nexport class InMemoryIndicatorRegistry implements IndicatorRegistry {\n  private defs = new Map<string, IndicatorDefinition>();\n\n  register(definition: IndicatorDefinition<any, any>): void {\n    this.defs.set(definition.id, definition);\n  }\n\n  get(id: string): IndicatorDefinition | undefined {\n    return this.defs.get(id);\n  }\n\n  listAll(): IndicatorDefinition[] {\n    return Array.from(this.defs.values());\n  }\n\n  listByCategory(category: IndicatorDefinition['category']): IndicatorDefinition[] {\n    return this.listAll().filter((def) => def.category === category);\n  }\n\n  listGPUEnabled(): IndicatorDefinition[] {\n    return this.listAll().filter((def) => Boolean(def.calculateGPU || def.wgslSource));\n  }\n\n  resolveDependencies(ids: string[]): IndicatorDefinition[] {\n    const resolved: IndicatorDefinition[] = [];\n    const visiting = new Set<string>();\n    const visited = new Set<string>();\n\n    const visit = (id: string) => {\n      if (visited.has(id)) return;\n      if (visiting.has(id)) {\n        throw new Error(`Circular dependency detected for indicator: ${id}`);\n      }\n\n      const def = this.get(id);\n      if (!def) {\n        throw new Error(`Indicator not found: ${id}`);\n      }\n\n      visiting.add(id);\n      for (const dep of def.dependencies ?? []) {\n        visit(dep);\n      }\n      visiting.delete(id);\n      visited.add(id);\n      resolved.push(def);\n    };\n\n    ids.forEach(visit);\n    return resolved;\n  }\n}\n",
    "export const SCHEMA_VERSION = 2 as const;\n\ntype GPUDevice = unknown;\n\nexport type IndicatorValue = number | null;\n\nexport type PlotStyle =\n  | 'line'\n  | 'histogram'\n  | 'area'\n  | 'band'\n  | 'marker'\n  | 'cloud'\n  | 'bar'\n  | 'candle';\n\nexport type PlotPane = 'main' | 'sub1' | 'sub2' | 'sub3';\n\nexport type ZLayer = 0 | 10 | 20 | 30 | 40 | 50;\n\nexport type SeriesStyle = {\n  name: string;\n  color: string;\n  lineWidth?: number;\n  style: PlotStyle;\n  opacity?: number;\n  fillTo?: string | number;\n  zLayer?: ZLayer;\n  antialias?: boolean;\n};\n\nexport type IndicatorParamSchema<T> = {\n  [K in keyof T]: {\n    type: 'number' | 'string' | 'boolean' | 'select';\n    default: T[K];\n    label: string;\n    description?: string;\n    min?: number;\n    max?: number;\n    step?: number;\n    options?: { value: unknown; label: string }[];\n  };\n};\n\nexport type IndicatorError = {\n  code: 'INSUFFICIENT_DATA' | 'INVALID_PARAMS' | 'GPU_ERROR' | 'COMPUTATION_ERROR';\n  message: string;\n  details?: unknown;\n};\n\nexport type IndicatorResult<T> =\n  | { ok: true; value: T }\n  | { ok: false; error: IndicatorError };\n\nexport type MultiSeriesOutput = Record<string, IndicatorValue[]>;\n\nexport type IndicatorAlert = {\n  id: string;\n  name: string;\n  condition: (\n    values: Record<string, IndicatorValue>,\n    bar: unknown,\n    prevValues?: Record<string, IndicatorValue>\n  ) => boolean;\n  message: (values: Record<string, IndicatorValue>, bar: unknown) => string;\n  severity: 'info' | 'warning' | 'critical';\n  cooldown?: number;\n};\n\nexport type IndicatorDefinition<TParams = Record<string, unknown>, TBar = unknown> = {\n  schemaVersion: typeof SCHEMA_VERSION;\n  id: string;\n  name: string;\n  nameKey?: string;\n  category: 'trend' | 'momentum' | 'volatility' | 'volume' | 'custom';\n  pane: PlotPane;\n  outputs: SeriesStyle[];\n  params: IndicatorParamSchema<TParams>;\n  dependencies?: string[];\n  calculate: (data: TBar[], params: TParams) => IndicatorResult<MultiSeriesOutput>;\n  calculateGPU?: (\n    buffer: Float32Array,\n    params: TParams,\n    device: GPUDevice\n  ) => Promise<IndicatorResult<Record<string, Float32Array>>>;\n  wgslSource?: string;\n  update?: (\n    prevState: unknown,\n    newBar: TBar,\n    params: TParams\n  ) => IndicatorResult<{ state: unknown; values: Record<string, IndicatorValue> }>;\n  yRange?: { min: number; max: number };\n  horizontalLines?: { value: number; color: string; dashed?: boolean }[];\n  alerts?: IndicatorAlert[];\n  complexity: {\n    time: 'O(n)' | 'O(n log n)' | 'O(n²)';\n    space: 'O(1)' | 'O(n)' | 'O(n²)';\n  };\n  warmupPeriod: (params: TParams) => number;\n};\n",
    "import type { OhlcvPoint } from '../core/types';\nimport type {\n  IndicatorDefinition,\n  IndicatorResult,\n  IndicatorValue,\n  MultiSeriesOutput,\n} from '../core/indicatorTypes';\nimport { SCHEMA_VERSION } from '../core/indicatorTypes';\nimport type { IndicatorRegistry } from '../core/indicators';\n\nconst ok = (value: MultiSeriesOutput): IndicatorResult<MultiSeriesOutput> => ({ ok: true, value });\nconst fail = (message: string): IndicatorResult<MultiSeriesOutput> => ({\n  ok: false,\n  error: { code: 'COMPUTATION_ERROR', message },\n});\n\nexport const SMA: IndicatorDefinition<{ period: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'sma',\n  name: 'SMA',\n  category: 'trend',\n  pane: 'main',\n  outputs: [{ name: 'sma', color: '#4ECDC4', style: 'line', lineWidth: 1, zLayer: 30 }],\n  params: {\n    period: { type: 'number', default: 20, label: 'Period', min: 2, max: 200 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period - 1,\n  calculate(data, { period }) {\n    try {\n      const sma: IndicatorValue[] = [];\n      let sum = 0;\n      for (let i = 0; i < data.length; i++) {\n        sum += data[i].close;\n        if (i >= period) sum -= data[i - period].close;\n        if (i < period - 1) {\n          sma.push(null);\n        } else {\n          sma.push(sum / period);\n        }\n      }\n      return ok({ sma });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { period: u32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>;\n    @compute @workgroup_size(256)\n    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n      let idx = gid.x;\n      if (idx >= params.data_len) { return; }\n      if (idx < params.period - 1u) {\n        output[idx] = bitcast<f32>(0x7FC00000u);\n        return;\n      }\n      var sum: f32 = 0.0;\n      for (var j: u32 = 0u; j < params.period; j++) {\n        let close_idx = (idx - params.period + 1u + j) * 6u + 4u;\n        sum += ohlcv[close_idx];\n      }\n      output[idx] = sum / f32(params.period);\n    }\n  `,\n};\n\nexport const EMA: IndicatorDefinition<{ period: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'ema',\n  name: 'EMA',\n  category: 'trend',\n  pane: 'main',\n  outputs: [{ name: 'ema', color: '#FFB703', style: 'line', lineWidth: 1, zLayer: 30 }],\n  params: {\n    period: { type: 'number', default: 20, label: 'Period', min: 2, max: 200 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period - 1,\n  calculate(data, { period }) {\n    try {\n      const ema: IndicatorValue[] = [];\n      const k = 2 / (period + 1);\n      for (let i = 0; i < data.length; i++) {\n        if (i === 0) {\n          ema.push(data[i].close);\n          continue;\n        }\n        const prev = ema[i - 1] ?? data[i - 1].close;\n        ema.push(data[i].close * k + (prev as number) * (1 - k));\n      }\n      for (let i = 0; i < period - 1; i++) {\n        ema[i] = null;\n      }\n      return ok({ ema });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { period: u32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>;\n    @compute @workgroup_size(1)\n    fn main() {\n      let n = params.data_len;\n      if (n == 0u) { return; }\n      let k = 2.0 / (f32(params.period) + 1.0);\n      output[0u] = ohlcv[4u];\n      for (var i: u32 = 1u; i < n; i++) {\n        let close = ohlcv[i * 6u + 4u];\n        output[i] = close * k + output[i - 1u] * (1.0 - k);\n      }\n      for (var i: u32 = 0u; i < params.period - 1u && i < n; i++) {\n        output[i] = bitcast<f32>(0x7FC00000u);\n      }\n    }\n  `,\n};\n\nexport const BollingerBands: IndicatorDefinition<{ period: number; stdDev: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'bb',\n  name: 'Bollinger Bands',\n  category: 'volatility',\n  pane: 'main',\n  outputs: [\n    { name: 'upper', color: '#2196F3', style: 'line', lineWidth: 1, zLayer: 30 },\n    { name: 'middle', color: '#9E9E9E', style: 'line', lineWidth: 1, zLayer: 30 },\n    { name: 'lower', color: '#2196F3', style: 'line', lineWidth: 1, zLayer: 30 },\n    { name: 'fill', color: 'rgba(33,150,243,0.1)', style: 'band', fillTo: 'lower', zLayer: 10 },\n  ],\n  params: {\n    period: { type: 'number', default: 20, label: 'Period', min: 5, max: 100 },\n    stdDev: { type: 'number', default: 2.0, label: 'Std Dev', min: 0.5, max: 4.0, step: 0.1 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period - 1,\n  calculate(data, { period, stdDev }) {\n    try {\n      const upper: IndicatorValue[] = [];\n      const middle: IndicatorValue[] = [];\n      const lower: IndicatorValue[] = [];\n      for (let i = 0; i < data.length; i++) {\n        if (i < period - 1) {\n          upper.push(null);\n          middle.push(null);\n          lower.push(null);\n          continue;\n        }\n        const slice = data.slice(i - period + 1, i + 1);\n        const closes = slice.map((d) => d.close);\n        const sma = closes.reduce((a, b) => a + b, 0) / period;\n        const variance = closes.reduce((a, b) => a + (b - sma) ** 2, 0) / period;\n        const std = Math.sqrt(variance);\n        middle.push(sma);\n        upper.push(sma + stdDev * std);\n        lower.push(sma - stdDev * std);\n      }\n      return ok({ upper, middle, lower, fill: upper });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { period: u32, std_dev: f32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>;\n    @compute @workgroup_size(256)\n    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n      let idx = gid.x;\n      if (idx >= params.data_len) { return; }\n      if (idx < params.period - 1u) {\n        output[idx * 3u + 0u] = bitcast<f32>(0x7FC00000u);\n        output[idx * 3u + 1u] = bitcast<f32>(0x7FC00000u);\n        output[idx * 3u + 2u] = bitcast<f32>(0x7FC00000u);\n        return;\n      }\n      var sum: f32 = 0.0;\n      for (var j: u32 = 0u; j < params.period; j++) {\n        let close_idx = (idx - params.period + 1u + j) * 6u + 4u;\n        sum += ohlcv[close_idx];\n      }\n      let sma = sum / f32(params.period);\n      var var_sum: f32 = 0.0;\n      for (var j: u32 = 0u; j < params.period; j++) {\n        let close_idx = (idx - params.period + 1u + j) * 6u + 4u;\n        let diff = ohlcv[close_idx] - sma;\n        var_sum += diff * diff;\n      }\n      let std = sqrt(var_sum / f32(params.period));\n      output[idx * 3u + 0u] = sma + params.std_dev * std;\n      output[idx * 3u + 1u] = sma;\n      output[idx * 3u + 2u] = sma - params.std_dev * std;\n    }\n  `,\n};\n\nexport const Volume: IndicatorDefinition<{ maPeriod: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'volume',\n  name: 'Volume',\n  category: 'volume',\n  pane: 'sub1',\n  outputs: [\n    { name: 'volume', color: '#90CAF9', style: 'bar', opacity: 0.8, zLayer: 20 },\n    { name: 'volumeMA', color: '#1565C0', style: 'line', lineWidth: 1, zLayer: 30 },\n  ],\n  params: {\n    maPeriod: { type: 'number', default: 20, label: 'MA Period', min: 5, max: 50 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ maPeriod }) => maPeriod - 1,\n  calculate(data, { maPeriod }) {\n    try {\n      const volume: IndicatorValue[] = data.map((d) => d.volume);\n      const volumeMA: IndicatorValue[] = [];\n      for (let i = 0; i < data.length; i++) {\n        if (i < maPeriod - 1) {\n          volumeMA.push(null);\n        } else {\n          const slice = data.slice(i - maPeriod + 1, i + 1);\n          const avg = slice.reduce((a, b) => a + b.volume, 0) / maPeriod;\n          volumeMA.push(avg);\n        }\n      }\n      return ok({ volume, volumeMA });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n};\n\nexport const PivotPoints: IndicatorDefinition<{}, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'pivot_points',\n  name: 'Pivot Points',\n  category: 'trend',\n  pane: 'main',\n  outputs: [\n    { name: 'pivot', color: '#607D8B', style: 'line', lineWidth: 1, zLayer: 30 },\n    { name: 'r1', color: '#8BC34A', style: 'line', lineWidth: 1, zLayer: 30 },\n    { name: 's1', color: '#F44336', style: 'line', lineWidth: 1, zLayer: 30 },\n    { name: 'r2', color: '#4CAF50', style: 'line', lineWidth: 1, zLayer: 30 },\n    { name: 's2', color: '#E57373', style: 'line', lineWidth: 1, zLayer: 30 },\n  ],\n  params: {},\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: () => 1,\n  calculate(data) {\n    try {\n      const pivot: IndicatorValue[] = [];\n      const r1: IndicatorValue[] = [];\n      const s1: IndicatorValue[] = [];\n      const r2: IndicatorValue[] = [];\n      const s2: IndicatorValue[] = [];\n      for (let i = 0; i < data.length; i++) {\n        if (i === 0) {\n          pivot.push(null);\n          r1.push(null);\n          s1.push(null);\n          r2.push(null);\n          s2.push(null);\n          continue;\n        }\n        const prev = data[i - 1];\n        const p = (prev.high + prev.low + prev.close) / 3;\n        const r1v = 2 * p - prev.low;\n        const s1v = 2 * p - prev.high;\n        const r2v = p + (prev.high - prev.low);\n        const s2v = p - (prev.high - prev.low);\n        pivot.push(p);\n        r1.push(r1v);\n        s1.push(s1v);\n        r2.push(r2v);\n        s2.push(s2v);\n      }\n      return ok({ pivot, r1, s1, r2, s2 });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n};\n\nexport const Phase1Indicators = [Volume, SMA, EMA, BollingerBands, PivotPoints] as const;\n\nexport const registerPhase1Indicators = (registry: IndicatorRegistry): void => {\n  Phase1Indicators.forEach((indicator) => registry.register(indicator as IndicatorDefinition<any, any>));\n};\n",
    "import type { OhlcvPoint } from '../core/types';\nimport type {\n  IndicatorDefinition,\n  IndicatorResult,\n  IndicatorValue,\n  MultiSeriesOutput,\n} from '../core/indicatorTypes';\nimport { SCHEMA_VERSION } from '../core/indicatorTypes';\nimport type { IndicatorRegistry } from '../core/indicators';\n\nconst ok = (value: MultiSeriesOutput): IndicatorResult<MultiSeriesOutput> => ({ ok: true, value });\nconst fail = (message: string): IndicatorResult<MultiSeriesOutput> => ({\n  ok: false,\n  error: { code: 'COMPUTATION_ERROR', message },\n});\n\nexport const RSI: IndicatorDefinition<{ period: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'rsi',\n  name: 'RSI',\n  category: 'momentum',\n  pane: 'sub1',\n  outputs: [{ name: 'rsi', color: '#9C27B0', style: 'line', lineWidth: 1.5, zLayer: 30 }],\n  params: {\n    period: { type: 'number', default: 14, label: 'Period', min: 2, max: 50 },\n  },\n  yRange: { min: 0, max: 100 },\n  horizontalLines: [\n    { value: 70, color: '#F44336', dashed: true },\n    { value: 30, color: '#4CAF50', dashed: true },\n    { value: 50, color: '#9E9E9E', dashed: true },\n  ],\n  complexity: { time: 'O(n)', space: 'O(1)' },\n  warmupPeriod: ({ period }) => period,\n  calculate(data, { period }) {\n    try {\n      const rsi: IndicatorValue[] = [];\n      let avgGain = 0;\n      let avgLoss = 0;\n      for (let i = 0; i < data.length; i++) {\n        if (i === 0) {\n          rsi.push(null);\n          continue;\n        }\n        const change = data[i].close - data[i - 1].close;\n        const gain = change > 0 ? change : 0;\n        const loss = change < 0 ? -change : 0;\n        if (i < period) {\n          avgGain += gain / period;\n          avgLoss += loss / period;\n          rsi.push(null);\n        } else if (i === period) {\n          avgGain += gain / period;\n          avgLoss += loss / period;\n          const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;\n          rsi.push(100 - 100 / (1 + rs));\n        } else {\n          avgGain = (avgGain * (period - 1) + gain) / period;\n          avgLoss = (avgLoss * (period - 1) + loss) / period;\n          const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;\n          rsi.push(100 - 100 / (1 + rs));\n        }\n      }\n      return ok({ rsi });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { period: u32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>;\n    @compute @workgroup_size(1)\n    fn main() {\n      let period = params.period;\n      let n = params.data_len;\n      var avg_gain: f32 = 0.0;\n      var avg_loss: f32 = 0.0;\n      if (n <= period + 1u) { return; }\n      for (var i: u32 = 1u; i <= period; i++) {\n        let change = ohlcv[i * 6u + 4u] - ohlcv[(i - 1u) * 6u + 4u];\n        if (change > 0.0) { avg_gain += change; }\n        else { avg_loss -= change; }\n      }\n      avg_gain /= f32(period);\n      avg_loss /= f32(period);\n      for (var i: u32 = 0u; i < period; i++) {\n        output[i] = bitcast<f32>(0x7FC00000u);\n      }\n      let rs0 = select(avg_gain / avg_loss, 100.0, avg_loss == 0.0);\n      output[period] = 100.0 - 100.0 / (1.0 + rs0);\n      for (var i: u32 = period + 1u; i < n; i++) {\n        let change = ohlcv[i * 6u + 4u] - ohlcv[(i - 1u) * 6u + 4u];\n        let gain = max(change, 0.0);\n        let loss = max(-change, 0.0);\n        avg_gain = (avg_gain * f32(period - 1u) + gain) / f32(period);\n        avg_loss = (avg_loss * f32(period - 1u) + loss) / f32(period);\n        let rs = select(avg_gain / avg_loss, 100.0, avg_loss == 0.0);\n        output[i] = 100.0 - 100.0 / (1.0 + rs);\n      }\n    }\n  `,\n};\n\nexport const ATR: IndicatorDefinition<{ period: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'atr',\n  name: 'ATR',\n  category: 'volatility',\n  pane: 'sub1',\n  outputs: [{ name: 'atr', color: '#795548', style: 'line', lineWidth: 1.5, zLayer: 30 }],\n  params: {\n    period: { type: 'number', default: 14, label: 'Period', min: 5, max: 50 },\n  },\n  complexity: { time: 'O(n)', space: 'O(1)' },\n  warmupPeriod: ({ period }) => period,\n  calculate(data, { period }) {\n    try {\n      const atr: IndicatorValue[] = [];\n      let atrSum = 0;\n      for (let i = 0; i < data.length; i++) {\n        if (i === 0) {\n          atr.push(null);\n          continue;\n        }\n        const tr = Math.max(\n          data[i].high - data[i].low,\n          Math.abs(data[i].high - data[i - 1].close),\n          Math.abs(data[i].low - data[i - 1].close)\n        );\n        if (i < period) {\n          atrSum += tr;\n          atr.push(null);\n        } else if (i === period) {\n          atrSum += tr;\n          atr.push(atrSum / period);\n        } else {\n          const prevATR = (atr[i - 1] ?? 0) as number;\n          atr.push((prevATR * (period - 1) + tr) / period);\n        }\n      }\n      return ok({ atr });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { period: u32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>;\n    @compute @workgroup_size(1)\n    fn main() {\n      let period = params.period;\n      let n = params.data_len;\n      if (n == 0u) { return; }\n      output[0u] = bitcast<f32>(0x7FC00000u);\n      var atr_sum: f32 = 0.0;\n      for (var i: u32 = 1u; i < n; i++) {\n        let high = ohlcv[i * 6u + 2u];\n        let low = ohlcv[i * 6u + 3u];\n        let prev_close = ohlcv[(i - 1u) * 6u + 4u];\n        let tr = max(high - low, max(abs(high - prev_close), abs(low - prev_close)));\n        if (i < period) {\n          atr_sum += tr;\n          output[i] = bitcast<f32>(0x7FC00000u);\n        } else if (i == period) {\n          atr_sum += tr;\n          output[i] = atr_sum / f32(period);\n        } else {\n          let prev_atr = output[i - 1u];\n          output[i] = (prev_atr * f32(period - 1u) + tr) / f32(period);\n        }\n      }\n    }\n  `,\n};\n\nexport const MACD: IndicatorDefinition<\n  { fastPeriod: number; slowPeriod: number; signalPeriod: number },\n  OhlcvPoint\n> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'macd',\n  name: 'MACD',\n  category: 'momentum',\n  pane: 'sub2',\n  dependencies: ['ema'],\n  outputs: [\n    { name: 'macd', color: '#2196F3', style: 'line', lineWidth: 1.5, zLayer: 30 },\n    { name: 'signal', color: '#FF9800', style: 'line', lineWidth: 1, zLayer: 30 },\n    { name: 'histogram', color: '#4CAF50', style: 'histogram', opacity: 0.7, zLayer: 20 },\n  ],\n  params: {\n    fastPeriod: { type: 'number', default: 12, label: 'Fast Period', min: 2, max: 50 },\n    slowPeriod: { type: 'number', default: 26, label: 'Slow Period', min: 5, max: 100 },\n    signalPeriod: { type: 'number', default: 9, label: 'Signal Period', min: 2, max: 50 },\n  },\n  horizontalLines: [{ value: 0, color: '#9E9E9E', dashed: false }],\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ slowPeriod, signalPeriod }) => slowPeriod + signalPeriod - 1,\n  calculate(data, { fastPeriod, slowPeriod, signalPeriod }) {\n    try {\n      const ema = (values: number[], period: number): number[] => {\n        const result: number[] = [];\n        const k = 2 / (period + 1);\n        for (let i = 0; i < values.length; i++) {\n          if (i === 0) result.push(values[i]);\n          else result.push(values[i] * k + result[i - 1] * (1 - k));\n        }\n        return result;\n      };\n      const closes = data.map((d) => d.close);\n      const fastEma = ema(closes, fastPeriod);\n      const slowEma = ema(closes, slowPeriod);\n      const macdLine = fastEma.map((f, i) => f - slowEma[i]);\n      const signalLine = ema(macdLine, signalPeriod);\n      const histogram = macdLine.map((m, i) => m - signalLine[i]);\n      const warmup = slowPeriod + signalPeriod - 1;\n      return ok({\n        macd: macdLine.map((v, i) => (i < warmup ? null : v)),\n        signal: signalLine.map((v, i) => (i < warmup ? null : v)),\n        histogram: histogram.map((v, i) => (i < warmup ? null : v)),\n      });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { fast: u32, slow: u32, signal: u32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>; // macd, signal, hist packed\n    @compute @workgroup_size(1)\n    fn main() {\n      let n = params.data_len;\n      if (n == 0u) { return; }\n      let k_fast = 2.0 / (f32(params.fast) + 1.0);\n      let k_slow = 2.0 / (f32(params.slow) + 1.0);\n      let k_sig = 2.0 / (f32(params.signal) + 1.0);\n      var ema_fast: f32 = ohlcv[4u];\n      var ema_slow: f32 = ohlcv[4u];\n      var sig: f32 = 0.0;\n      for (var i: u32 = 0u; i < n; i++) {\n        let close = ohlcv[i * 6u + 4u];\n        if (i > 0u) {\n          ema_fast = close * k_fast + ema_fast * (1.0 - k_fast);\n          ema_slow = close * k_slow + ema_slow * (1.0 - k_slow);\n        }\n        let macd = ema_fast - ema_slow;\n        if (i == 0u) {\n          sig = macd;\n        } else {\n          sig = macd * k_sig + sig * (1.0 - k_sig);\n        }\n        let hist = macd - sig;\n        output[i * 3u + 0u] = macd;\n        output[i * 3u + 1u] = sig;\n        output[i * 3u + 2u] = hist;\n      }\n      let warmup = params.slow + params.signal - 1u;\n      for (var i: u32 = 0u; i < warmup && i < n; i++) {\n        output[i * 3u + 0u] = bitcast<f32>(0x7FC00000u);\n        output[i * 3u + 1u] = bitcast<f32>(0x7FC00000u);\n        output[i * 3u + 2u] = bitcast<f32>(0x7FC00000u);\n      }\n    }\n  `,\n};\n\nexport const ADX: IndicatorDefinition<{ period: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'adx',\n  name: 'ADX',\n  category: 'trend',\n  pane: 'sub1',\n  outputs: [\n    { name: 'adx', color: '#FF5722', style: 'line', lineWidth: 2, zLayer: 30 },\n    { name: 'plusDI', color: '#4CAF50', style: 'line', lineWidth: 1, zLayer: 30 },\n    { name: 'minusDI', color: '#F44336', style: 'line', lineWidth: 1, zLayer: 30 },\n  ],\n  params: {\n    period: { type: 'number', default: 14, label: 'Period', min: 5, max: 50 },\n  },\n  yRange: { min: 0, max: 100 },\n  horizontalLines: [\n    { value: 25, color: '#9E9E9E', dashed: true },\n    { value: 50, color: '#FF9800', dashed: true },\n  ],\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period * 2 - 1,\n  calculate(data, { period }) {\n    try {\n      const adx: IndicatorValue[] = [];\n      const plusDI: IndicatorValue[] = [];\n      const minusDI: IndicatorValue[] = [];\n      const tr: number[] = [];\n      const plusDM: number[] = [];\n      const minusDM: number[] = [];\n      for (let i = 0; i < data.length; i++) {\n        if (i === 0) {\n          tr.push(data[i].high - data[i].low);\n          plusDM.push(0);\n          minusDM.push(0);\n          adx.push(null);\n          plusDI.push(null);\n          minusDI.push(null);\n          continue;\n        }\n        const high = data[i].high;\n        const low = data[i].low;\n        const prevHigh = data[i - 1].high;\n        const prevLow = data[i - 1].low;\n        const prevClose = data[i - 1].close;\n        const trValue = Math.max(\n          high - low,\n          Math.abs(high - prevClose),\n          Math.abs(low - prevClose)\n        );\n        tr.push(trValue);\n        const upMove = high - prevHigh;\n        const downMove = prevLow - low;\n        plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);\n        minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);\n        if (i < period) {\n          adx.push(null);\n          plusDI.push(null);\n          minusDI.push(null);\n          continue;\n        }\n        let smoothTR = 0;\n        let smoothPlusDM = 0;\n        let smoothMinusDM = 0;\n        if (i === period) {\n          for (let j = 1; j <= period; j++) {\n            smoothTR += tr[j];\n            smoothPlusDM += plusDM[j];\n            smoothMinusDM += minusDM[j];\n          }\n        } else {\n          const prevSmoothTR = tr.slice(i - period, i).reduce((a, b) => a + b, 0);\n          smoothTR = prevSmoothTR - prevSmoothTR / period + tr[i];\n          const prevSmoothPlusDM = plusDM.slice(i - period, i).reduce((a, b) => a + b, 0);\n          smoothPlusDM = prevSmoothPlusDM - prevSmoothPlusDM / period + plusDM[i];\n          const prevSmoothMinusDM = minusDM.slice(i - period, i).reduce((a, b) => a + b, 0);\n          smoothMinusDM = prevSmoothMinusDM - prevSmoothMinusDM / period + minusDM[i];\n        }\n        const pdi = smoothTR > 0 ? (100 * smoothPlusDM) / smoothTR : 0;\n        const mdi = smoothTR > 0 ? (100 * smoothMinusDM) / smoothTR : 0;\n        plusDI.push(pdi);\n        minusDI.push(mdi);\n        const diSum = pdi + mdi;\n        const dx = diSum > 0 ? (100 * Math.abs(pdi - mdi)) / diSum : 0;\n        if (i < period * 2 - 1) {\n          adx.push(null);\n        } else if (i === period * 2 - 1) {\n          let dxSum = 0;\n          for (let j = period; j < period * 2; j++) {\n            const pdiJ = plusDI[j] ?? 0;\n            const mdiJ = minusDI[j] ?? 0;\n            const sumJ = pdiJ + mdiJ;\n            dxSum += sumJ > 0 ? (100 * Math.abs(pdiJ - mdiJ)) / sumJ : 0;\n          }\n          adx.push(dxSum / period);\n        } else {\n          const prevADX = (adx[i - 1] ?? 0) as number;\n          adx.push((prevADX * (period - 1) + dx) / period);\n        }\n      }\n      return ok({ adx, plusDI, minusDI });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { period: u32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>; // adx, plusDI, minusDI packed\n    @compute @workgroup_size(1)\n    fn main() {\n      let n = params.data_len;\n      if (n == 0u) { return; }\n      var smooth_tr: f32 = 0.0;\n      var smooth_plus: f32 = 0.0;\n      var smooth_minus: f32 = 0.0;\n      var prev_adx: f32 = 0.0;\n      for (var i: u32 = 0u; i < n; i++) {\n        if (i == 0u) {\n          output[i * 3u + 0u] = bitcast<f32>(0x7FC00000u);\n          output[i * 3u + 1u] = bitcast<f32>(0x7FC00000u);\n          output[i * 3u + 2u] = bitcast<f32>(0x7FC00000u);\n          continue;\n        }\n        let high = ohlcv[i * 6u + 2u];\n        let low = ohlcv[i * 6u + 3u];\n        let prev_high = ohlcv[(i - 1u) * 6u + 2u];\n        let prev_low = ohlcv[(i - 1u) * 6u + 3u];\n        let prev_close = ohlcv[(i - 1u) * 6u + 4u];\n        let tr = max(high - low, max(abs(high - prev_close), abs(low - prev_close)));\n        let up_move = high - prev_high;\n        let down_move = prev_low - low;\n        let plus_dm = select(up_move, 0.0, up_move > down_move && up_move > 0.0);\n        let minus_dm = select(down_move, 0.0, down_move > up_move && down_move > 0.0);\n        if (i <= params.period) {\n          smooth_tr += tr;\n          smooth_plus += plus_dm;\n          smooth_minus += minus_dm;\n          output[i * 3u + 0u] = bitcast<f32>(0x7FC00000u);\n          output[i * 3u + 1u] = bitcast<f32>(0x7FC00000u);\n          output[i * 3u + 2u] = bitcast<f32>(0x7FC00000u);\n          continue;\n        }\n        smooth_tr = smooth_tr - (smooth_tr / f32(params.period)) + tr;\n        smooth_plus = smooth_plus - (smooth_plus / f32(params.period)) + plus_dm;\n        smooth_minus = smooth_minus - (smooth_minus / f32(params.period)) + minus_dm;\n        let pdi = select((100.0 * smooth_plus) / smooth_tr, 0.0, smooth_tr == 0.0);\n        let mdi = select((100.0 * smooth_minus) / smooth_tr, 0.0, smooth_tr == 0.0);\n        let di_sum = pdi + mdi;\n        let dx = select((100.0 * abs(pdi - mdi)) / di_sum, 0.0, di_sum == 0.0);\n        if (i < params.period * 2u - 1u) {\n          output[i * 3u + 0u] = bitcast<f32>(0x7FC00000u);\n        } else if (i == params.period * 2u - 1u) {\n          prev_adx = dx;\n          output[i * 3u + 0u] = prev_adx;\n        } else {\n          prev_adx = (prev_adx * f32(params.period - 1u) + dx) / f32(params.period);\n          output[i * 3u + 0u] = prev_adx;\n        }\n        output[i * 3u + 1u] = pdi;\n        output[i * 3u + 2u] = mdi;\n      }\n    }\n  `,\n};\n\nexport const TradeMarkers: IndicatorDefinition<{}, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'trade_markers',\n  name: 'Trade Markers',\n  category: 'custom',\n  pane: 'main',\n  outputs: [{ name: 'markers', color: '#FFC107', style: 'marker', zLayer: 40 }],\n  params: {},\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: () => 0,\n  calculate() {\n    return ok({ markers: [] });\n  },\n};\n\nexport const Phase2Indicators = [RSI, ADX, ATR, MACD, TradeMarkers] as const;\n\nexport const registerPhase2Indicators = (registry: IndicatorRegistry): void => {\n  Phase2Indicators.forEach((indicator) => registry.register(indicator as IndicatorDefinition<any, any>));\n};\n",
    "import type { OhlcvPoint } from '../core/types';\nimport type {\n  IndicatorDefinition,\n  IndicatorResult,\n  IndicatorValue,\n  MultiSeriesOutput,\n} from '../core/indicatorTypes';\nimport { SCHEMA_VERSION } from '../core/indicatorTypes';\nimport type { IndicatorRegistry } from '../core/indicators';\n\nconst ok = (value: MultiSeriesOutput): IndicatorResult<MultiSeriesOutput> => ({ ok: true, value });\nconst fail = (message: string): IndicatorResult<MultiSeriesOutput> => ({\n  ok: false,\n  error: { code: 'COMPUTATION_ERROR', message },\n});\n\nexport const VWAP: IndicatorDefinition<{ period: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'vwap',\n  name: 'VWAP',\n  category: 'volume',\n  pane: 'main',\n  outputs: [{ name: 'vwap', color: '#6D4C41', style: 'line', lineWidth: 1.5, zLayer: 30 }],\n  params: {\n    period: { type: 'number', default: 20, label: 'Period', min: 2, max: 200 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period - 1,\n  calculate(data, { period }) {\n    try {\n      const vwap: IndicatorValue[] = [];\n      let pvSum = 0;\n      let vSum = 0;\n      for (let i = 0; i < data.length; i++) {\n        const typical = (data[i].high + data[i].low + data[i].close) / 3;\n        pvSum += typical * data[i].volume;\n        vSum += data[i].volume;\n\n        if (i >= period) {\n          const prev = data[i - period];\n          const prevTypical = (prev.high + prev.low + prev.close) / 3;\n          pvSum -= prevTypical * prev.volume;\n          vSum -= prev.volume;\n        }\n\n        if (i < period - 1 || vSum === 0) {\n          vwap.push(null);\n        } else {\n          vwap.push(pvSum / vSum);\n        }\n      }\n      return ok({ vwap });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { period: u32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>;\n    @compute @workgroup_size(1)\n    fn main() {\n      let period = params.period;\n      let n = params.data_len;\n      var pv_sum: f32 = 0.0;\n      var v_sum: f32 = 0.0;\n      for (var i: u32 = 0u; i < n; i++) {\n        let high = ohlcv[i * 6u + 2u];\n        let low = ohlcv[i * 6u + 3u];\n        let close = ohlcv[i * 6u + 4u];\n        let volume = ohlcv[i * 6u + 5u];\n        let typical = (high + low + close) / 3.0;\n        pv_sum += typical * volume;\n        v_sum += volume;\n        if (i >= period) {\n          let j = i - period;\n          let h = ohlcv[j * 6u + 2u];\n          let l = ohlcv[j * 6u + 3u];\n          let c = ohlcv[j * 6u + 4u];\n          let v = ohlcv[j * 6u + 5u];\n          let t = (h + l + c) / 3.0;\n          pv_sum -= t * v;\n          v_sum -= v;\n        }\n        if (i < period - 1u || v_sum == 0.0) {\n          output[i] = bitcast<f32>(0x7FC00000u);\n        } else {\n          output[i] = pv_sum / v_sum;\n        }\n      }\n    }\n  `,\n};\n\nexport const VolRatio: IndicatorDefinition<{ period: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'vol_ratio',\n  name: 'Vol Ratio',\n  category: 'volume',\n  pane: 'sub1',\n  outputs: [{ name: 'volRatio', color: '#00897B', style: 'line', lineWidth: 1.2, zLayer: 30 }],\n  params: {\n    period: { type: 'number', default: 20, label: 'Period', min: 2, max: 200 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period - 1,\n  calculate(data, { period }) {\n    try {\n      const volRatio: IndicatorValue[] = [];\n      let sum = 0;\n      for (let i = 0; i < data.length; i++) {\n        sum += data[i].volume;\n        if (i >= period) sum -= data[i - period].volume;\n        if (i < period - 1) {\n          volRatio.push(null);\n        } else {\n          const avg = sum / period;\n          volRatio.push(avg === 0 ? 0 : data[i].volume / avg);\n        }\n      }\n      return ok({ volRatio });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { period: u32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>;\n    @compute @workgroup_size(1)\n    fn main() {\n      let period = params.period;\n      let n = params.data_len;\n      var sum: f32 = 0.0;\n      for (var i: u32 = 0u; i < n; i++) {\n        let vol = ohlcv[i * 6u + 5u];\n        sum += vol;\n        if (i >= period) {\n          sum -= ohlcv[(i - period) * 6u + 5u];\n        }\n        if (i < period - 1u) {\n          output[i] = bitcast<f32>(0x7FC00000u);\n        } else {\n          let avg = sum / f32(period);\n          output[i] = select(vol / avg, 0.0, avg == 0.0);\n        }\n      }\n    }\n  `,\n};\n\nexport const PercentB: IndicatorDefinition<{ period: number; stdDev: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'percent_b',\n  name: '%B',\n  category: 'volatility',\n  pane: 'sub1',\n  outputs: [{ name: 'percentB', color: '#673AB7', style: 'line', lineWidth: 1.3, zLayer: 30 }],\n  params: {\n    period: { type: 'number', default: 20, label: 'Period', min: 5, max: 100 },\n    stdDev: { type: 'number', default: 2.0, label: 'Std Dev', min: 0.5, max: 4.0, step: 0.1 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period - 1,\n  calculate(data, { period, stdDev }) {\n    try {\n      const percentB: IndicatorValue[] = [];\n      for (let i = 0; i < data.length; i++) {\n        if (i < period - 1) {\n          percentB.push(null);\n          continue;\n        }\n        const slice = data.slice(i - period + 1, i + 1);\n        const closes = slice.map((d) => d.close);\n        const sma = closes.reduce((a, b) => a + b, 0) / period;\n        const variance = closes.reduce((a, b) => a + (b - sma) ** 2, 0) / period;\n        const std = Math.sqrt(variance);\n        const upper = sma + stdDev * std;\n        const lower = sma - stdDev * std;\n        const bandwidth = upper - lower;\n        percentB.push(bandwidth > 0 ? (data[i].close - lower) / bandwidth : 0.5);\n      }\n      return ok({ percentB });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { period: u32, std_dev: f32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>;\n    @compute @workgroup_size(256)\n    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n      let idx = gid.x;\n      if (idx >= params.data_len) { return; }\n      if (idx < params.period - 1u) {\n        output[idx] = bitcast<f32>(0x7FC00000u);\n        return;\n      }\n      var sum: f32 = 0.0;\n      for (var j: u32 = 0u; j < params.period; j++) {\n        let close_idx = (idx - params.period + 1u + j) * 6u + 4u;\n        sum += ohlcv[close_idx];\n      }\n      let sma = sum / f32(params.period);\n      var var_sum: f32 = 0.0;\n      for (var j: u32 = 0u; j < params.period; j++) {\n        let close_idx = (idx - params.period + 1u + j) * 6u + 4u;\n        let diff = ohlcv[close_idx] - sma;\n        var_sum += diff * diff;\n      }\n      let std = sqrt(var_sum / f32(params.period));\n      let upper = sma + params.std_dev * std;\n      let lower = sma - params.std_dev * std;\n      let width = upper - lower;\n      let close = ohlcv[idx * 6u + 4u];\n      output[idx] = select((close - lower) / width, 0.5, width == 0.0);\n    }\n  `,\n};\n\nexport const BBWidth: IndicatorDefinition<{ period: number; stdDev: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'bb_width',\n  name: 'BB Width',\n  category: 'volatility',\n  pane: 'sub1',\n  outputs: [{ name: 'width', color: '#00BCD4', style: 'area', opacity: 0.5, fillTo: 0, zLayer: 20 }],\n  params: {\n    period: { type: 'number', default: 20, label: 'Period', min: 5, max: 100 },\n    stdDev: { type: 'number', default: 2.0, label: 'Std Dev', min: 0.5, max: 4.0, step: 0.1 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period - 1,\n  calculate(data, { period, stdDev }) {\n    try {\n      const width: IndicatorValue[] = [];\n      for (let i = 0; i < data.length; i++) {\n        if (i < period - 1) {\n          width.push(null);\n          continue;\n        }\n        const slice = data.slice(i - period + 1, i + 1);\n        const closes = slice.map((d) => d.close);\n        const sma = closes.reduce((a, b) => a + b, 0) / period;\n        const variance = closes.reduce((a, b) => a + (b - sma) ** 2, 0) / period;\n        const std = Math.sqrt(variance);\n        const upper = sma + stdDev * std;\n        const lower = sma - stdDev * std;\n        width.push(sma > 0 ? (upper - lower) / sma : 0);\n      }\n      return ok({ width });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n  wgslSource: `\n    struct Params { period: u32, std_dev: f32, data_len: u32 };\n    @group(0) @binding(0) var<storage, read> ohlcv: array<f32>;\n    @group(0) @binding(1) var<uniform> params: Params;\n    @group(0) @binding(2) var<storage, read_write> output: array<f32>;\n    @compute @workgroup_size(256)\n    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n      let idx = gid.x;\n      if (idx >= params.data_len) { return; }\n      if (idx < params.period - 1u) {\n        output[idx] = bitcast<f32>(0x7FC00000u);\n        return;\n      }\n      var sum: f32 = 0.0;\n      for (var j: u32 = 0u; j < params.period; j++) {\n        let close_idx = (idx - params.period + 1u + j) * 6u + 4u;\n        sum += ohlcv[close_idx];\n      }\n      let sma = sum / f32(params.period);\n      var var_sum: f32 = 0.0;\n      for (var j: u32 = 0u; j < params.period; j++) {\n        let close_idx = (idx - params.period + 1u + j) * 6u + 4u;\n        let diff = ohlcv[close_idx] - sma;\n        var_sum += diff * diff;\n      }\n      let std = sqrt(var_sum / f32(params.period));\n      let upper = sma + params.std_dev * std;\n      let lower = sma - params.std_dev * std;\n      output[idx] = select((upper - lower) / sma, 0.0, sma == 0.0);\n    }\n  `,\n};\n\nexport const Phase3Indicators = [VWAP, VolRatio, PercentB, BBWidth] as const;\n\nexport const registerPhase3Indicators = (registry: IndicatorRegistry): void => {\n  Phase3Indicators.forEach((indicator) => registry.register(indicator as IndicatorDefinition<any, any>));\n};\n",
    "import type { OhlcvPoint } from '../core/types';\nimport type {\n  IndicatorDefinition,\n  IndicatorResult,\n  IndicatorValue,\n  MultiSeriesOutput,\n} from '../core/indicatorTypes';\nimport { SCHEMA_VERSION } from '../core/indicatorTypes';\nimport type { IndicatorRegistry } from '../core/indicators';\n\nconst ok = (value: MultiSeriesOutput): IndicatorResult<MultiSeriesOutput> => ({ ok: true, value });\nconst fail = (message: string): IndicatorResult<MultiSeriesOutput> => ({\n  ok: false,\n  error: { code: 'COMPUTATION_ERROR', message },\n});\n\nexport const OBV: IndicatorDefinition<{}, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'obv',\n  name: 'OBV',\n  category: 'volume',\n  pane: 'sub1',\n  outputs: [{ name: 'obv', color: '#3F51B5', style: 'line', lineWidth: 1.2, zLayer: 30 }],\n  params: {},\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: () => 1,\n  calculate(data) {\n    try {\n      const obv: IndicatorValue[] = [];\n      let current = 0;\n      for (let i = 0; i < data.length; i++) {\n        if (i === 0) {\n          obv.push(null);\n          continue;\n        }\n        if (data[i].close > data[i - 1].close) {\n          current += data[i].volume;\n        } else if (data[i].close < data[i - 1].close) {\n          current -= data[i].volume;\n        }\n        obv.push(current);\n      }\n      return ok({ obv });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n};\n\nexport const CMF: IndicatorDefinition<{ period: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'cmf',\n  name: 'CMF',\n  category: 'volume',\n  pane: 'sub1',\n  outputs: [{ name: 'cmf', color: '#8BC34A', style: 'line', lineWidth: 1.2, zLayer: 30 }],\n  params: {\n    period: { type: 'number', default: 21, label: 'Period', min: 2, max: 200 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period - 1,\n  calculate(data, { period }) {\n    try {\n      const cmf: IndicatorValue[] = [];\n      let sumMFV = 0;\n      let sumVol = 0;\n      for (let i = 0; i < data.length; i++) {\n        const high = data[i].high;\n        const low = data[i].low;\n        const close = data[i].close;\n        const volume = data[i].volume;\n        const range = high - low;\n        const mfm = range === 0 ? 0 : ((close - low) - (high - close)) / range;\n        const mfv = mfm * volume;\n        sumMFV += mfv;\n        sumVol += volume;\n        if (i >= period) {\n          const prev = data[i - period];\n          const prevRange = prev.high - prev.low;\n          const prevMfm = prevRange === 0 ? 0 : ((prev.close - prev.low) - (prev.high - prev.close)) / prevRange;\n          sumMFV -= prevMfm * prev.volume;\n          sumVol -= prev.volume;\n        }\n        if (i < period - 1 || sumVol === 0) {\n          cmf.push(null);\n        } else {\n          cmf.push(sumMFV / sumVol);\n        }\n      }\n      return ok({ cmf });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n};\n\nexport const MFI: IndicatorDefinition<{ period: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'mfi',\n  name: 'MFI',\n  category: 'volume',\n  pane: 'sub1',\n  outputs: [{ name: 'mfi', color: '#FF7043', style: 'line', lineWidth: 1.2, zLayer: 30 }],\n  params: {\n    period: { type: 'number', default: 14, label: 'Period', min: 2, max: 200 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period,\n  calculate(data, { period }) {\n    try {\n      const mfi: IndicatorValue[] = [];\n      let posSum = 0;\n      let negSum = 0;\n      const typicalPrices = data.map((d) => (d.high + d.low + d.close) / 3);\n      for (let i = 0; i < data.length; i++) {\n        if (i === 0) {\n          mfi.push(null);\n          continue;\n        }\n        const tp = typicalPrices[i];\n        const prevTp = typicalPrices[i - 1];\n        const mf = tp * data[i].volume;\n        if (tp > prevTp) posSum += mf;\n        else if (tp < prevTp) negSum += mf;\n\n        if (i >= period) {\n          const oldTp = typicalPrices[i - period];\n          const oldPrevTp = typicalPrices[i - period - 1];\n          const oldMf = oldTp * data[i - period].volume;\n          if (oldTp > oldPrevTp) posSum -= oldMf;\n          else if (oldTp < oldPrevTp) negSum -= oldMf;\n        }\n\n        if (i < period) {\n          mfi.push(null);\n        } else {\n          const ratio = negSum === 0 ? 100 : posSum / negSum;\n          mfi.push(100 - 100 / (1 + ratio));\n        }\n      }\n      return ok({ mfi });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n};\n\nexport const KaufmanPatterns: IndicatorDefinition<{}, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'kaufman_patterns',\n  name: 'Kaufman Patterns',\n  category: 'custom',\n  pane: 'main',\n  outputs: [{ name: 'kaufman', color: '#FFC107', style: 'marker', zLayer: 40 }],\n  params: {},\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: () => 2,\n  calculate() {\n    return ok({ kaufman: [] });\n  },\n};\n\nexport const SqueezeAlert: IndicatorDefinition<{ period: number; stdDev: number; threshold: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'squeeze_alert',\n  name: 'Squeeze Alert',\n  category: 'volatility',\n  pane: 'main',\n  outputs: [{ name: 'squeeze', color: '#FF9800', style: 'marker', zLayer: 40 }],\n  params: {\n    period: { type: 'number', default: 20, label: 'Period', min: 5, max: 100 },\n    stdDev: { type: 'number', default: 2.0, label: 'Std Dev', min: 0.5, max: 4.0, step: 0.1 },\n    threshold: { type: 'number', default: 0.04, label: 'Threshold', min: 0.01, max: 0.2, step: 0.01 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period - 1,\n  calculate(data, { period, stdDev, threshold }) {\n    try {\n      const squeeze: IndicatorValue[] = [];\n      for (let i = 0; i < data.length; i++) {\n        if (i < period - 1) {\n          squeeze.push(null);\n          continue;\n        }\n        const slice = data.slice(i - period + 1, i + 1);\n        const closes = slice.map((d) => d.close);\n        const sma = closes.reduce((a, b) => a + b, 0) / period;\n        const variance = closes.reduce((a, b) => a + (b - sma) ** 2, 0) / period;\n        const std = Math.sqrt(variance);\n        const upper = sma + stdDev * std;\n        const lower = sma - stdDev * std;\n        const width = sma > 0 ? (upper - lower) / sma : 0;\n        squeeze.push(width < threshold ? data[i].close : null);\n      }\n      return ok({ squeeze });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n};\n\nexport const Divergence: IndicatorDefinition<{ period: number }, OhlcvPoint> = {\n  schemaVersion: SCHEMA_VERSION,\n  id: 'divergence',\n  name: 'Divergence',\n  category: 'custom',\n  pane: 'main',\n  outputs: [{ name: 'divergence', color: '#FFC107', style: 'marker', zLayer: 40 }],\n  params: {\n    period: { type: 'number', default: 14, label: 'Period', min: 2, max: 50 },\n  },\n  complexity: { time: 'O(n)', space: 'O(n)' },\n  warmupPeriod: ({ period }) => period,\n  calculate(data, { period }) {\n    try {\n      const rsi: number[] = [];\n      let avgGain = 0;\n      let avgLoss = 0;\n      for (let i = 0; i < data.length; i++) {\n        if (i === 0) {\n          rsi.push(NaN);\n          continue;\n        }\n        const change = data[i].close - data[i - 1].close;\n        const gain = change > 0 ? change : 0;\n        const loss = change < 0 ? -change : 0;\n        if (i < period) {\n          avgGain += gain / period;\n          avgLoss += loss / period;\n          rsi.push(NaN);\n        } else if (i === period) {\n          avgGain += gain / period;\n          avgLoss += loss / period;\n          const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;\n          rsi.push(100 - 100 / (1 + rs));\n        } else {\n          avgGain = (avgGain * (period - 1) + gain) / period;\n          avgLoss = (avgLoss * (period - 1) + loss) / period;\n          const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;\n          rsi.push(100 - 100 / (1 + rs));\n        }\n      }\n      const divergence: IndicatorValue[] = [];\n      for (let i = 0; i < data.length; i++) {\n        if (i < period + 2) {\n          divergence.push(null);\n          continue;\n        }\n        const prev = i - 2;\n        const priceHigher = data[i].close > data[prev].close;\n        const rsiLower = rsi[i] < rsi[prev];\n        divergence.push(priceHigher && rsiLower ? data[i].close : null);\n      }\n      return ok({ divergence });\n    } catch (e) {\n      return fail(String(e));\n    }\n  },\n};\n\nexport const Phase4Indicators = [OBV, CMF, MFI, KaufmanPatterns, SqueezeAlert, Divergence] as const;\n\nexport const registerPhase4Indicators = (registry: IndicatorRegistry): void => {\n  Phase4Indicators.forEach((indicator) => registry.register(indicator as IndicatorDefinition<any, any>));\n};\n",
    "export type TradeMarkerType =\n  | 'entry_long'\n  | 'entry_short'\n  | 'exit_long'\n  | 'exit_short'\n  | 'stop_loss'\n  | 'take_profit'\n  | 'signal'\n  | 'alert';\n\nexport type TradeMarker = {\n  type: TradeMarkerType;\n  time: number;\n  price: number;\n  label?: string;\n  size?: number;\n  metadata?: {\n    tradeId?: string;\n    profit?: number;\n    quantity?: number;\n    strategy?: string;\n  };\n};\n\nexport type TradeMarkerStyle = {\n  shape: 'triangle_up' | 'triangle_down' | 'circle' | 'cross' | 'diamond' | 'warning';\n  color: string;\n  borderColor?: string;\n  size: number;\n};\n\nexport const DEFAULT_MARKER_STYLES: Record<TradeMarkerType, TradeMarkerStyle> = {\n  entry_long: { shape: 'triangle_up', color: '#4CAF50', size: 10 },\n  entry_short: { shape: 'triangle_down', color: '#F44336', size: 10 },\n  exit_long: { shape: 'triangle_up', color: '#81C784', borderColor: '#4CAF50', size: 8 },\n  exit_short: { shape: 'triangle_down', color: '#E57373', borderColor: '#F44336', size: 8 },\n  stop_loss: { shape: 'cross', color: '#F44336', size: 10 },\n  take_profit: { shape: 'circle', color: '#4CAF50', size: 8 },\n  signal: { shape: 'diamond', color: '#FFC107', size: 8 },\n  alert: { shape: 'warning', color: '#FF9800', size: 10 },\n};\n",
    "// Core chart class: data management, series API and wiring to renderer\nexport interface ChartCoreOptions {\n  width?: number;\n  height?: number;\n  locale?: string;\n  theme?: 'light' | 'dark';\n}\n\nexport interface SeriesOptions {\n  id?: string;\n  type?: 'candlestick' | 'line' | 'bar' | 'area';\n  color?: string;\n  name?: string;\n  // Rendering colors (optional)\n  outlineColor?: string; // frame and outline (color A)\n  wickColor?: string; // wick color (color A)\n  upColor?: string; // fill when close >= open (bull) (color B)\n  downColor?: string; // fill when close < open (bear) (color C)\n}\n\nimport { CanvasRenderer } from '../renderer/canvas/canvasRenderer';\n\n// Minimal ChartCore skeleton to be expanded.\nexport class ChartCore {\n  private container: HTMLElement;\n  private options: ChartCoreOptions;\n\n  // internal series store: id -> {options, data}\n  private seriesStore: Map<string, { options: SeriesOptions; data: any[] }> = new Map();\n  // viewport state (indices relative to series data)\n  private viewportStartIndex: number = 0;\n  private viewportVisibleCount: number = 200;\n\n  // simple event emitter\n  private listeners: Map<string, Set<(payload?: any) => void>> = new Map();\n\n  constructor(container: HTMLElement, options?: ChartCoreOptions) {\n    if (!container) throw new Error('Container element required');\n    this.container = container;\n    this.options = options ?? {};\n    // initialize canvas renderer: prefer an existing canvas inside container\n    try {\n      const canvas = (this.container.tagName.toLowerCase() === 'canvas')\n        ? (this.container as unknown as HTMLCanvasElement)\n        : (this.container.querySelector('canvas') as HTMLCanvasElement) ?? this.createCanvas();\n      (this as any)._renderer = new CanvasRenderer(canvas);\n    } catch (e) {\n      console.warn('CanvasRenderer init failed', e);\n    }\n  }\n\n  // Event emitter helpers\n  on(event: string, cb: (payload?: any) => void) {\n    const set = this.listeners.get(event) ?? new Set();\n    set.add(cb);\n    this.listeners.set(event, set);\n  }\n  off(event: string, cb?: (payload?: any) => void) {\n    if (!this.listeners.has(event)) return;\n    if (!cb) { this.listeners.delete(event); return; }\n    this.listeners.get(event)!.delete(cb);\n  }\n  private emit(event: string, payload?: any) {\n    const set = this.listeners.get(event);\n    if (!set) return;\n    for (const cb of Array.from(set)) cb(payload);\n  }\n\n  // Feed adapter contract: adapter should implement subscribe/unsubscribe or similar\n  async connectFeed(adapter: any): Promise<void> {\n    // basic wiring: adapter.subscribe(seriesId, callback)\n    if (!adapter) throw new Error('Adapter required');\n    if (typeof adapter.subscribe !== 'function') {\n      console.warn('Adapter does not implement subscribe/unsubscribe — storing adapter only');\n      // store adapter for future use\n      (this as any)._adapter = adapter;\n      return;\n    }\n    (this as any)._adapter = adapter;\n    // subscribe all series if adapter supports it\n    for (const seriesId of this.seriesStore.keys()) {\n      try {\n        adapter.subscribe(seriesId, (point: any) => this.pushRealtime(seriesId, point));\n      } catch (e) {\n        console.warn('subscribe failed for', seriesId, e);\n      }\n    }\n    this.emit('realtimeConnected');\n  }\n\n  async disconnectFeed(): Promise<void> {\n    const adapter = (this as any)._adapter;\n    if (adapter && typeof adapter.unsubscribe === 'function') {\n      for (const seriesId of this.seriesStore.keys()) {\n        try { adapter.unsubscribe(seriesId); } catch {};\n      }\n    }\n    delete (this as any)._adapter;\n    this.emit('realtimeDisconnected');\n  }\n\n  async addSeries(options: SeriesOptions): Promise<string> {\n    const id = options.id ?? `series_${Math.random().toString(36).slice(2,9)}`;\n    if (this.seriesStore.has(id)) throw new Error(`Series ${id} already exists`);\n    this.seriesStore.set(id, { options, data: [] });\n    this.emit('seriesAdded', { id, options });\n    return id;\n  }\n\n  async setSeriesData(seriesId: string, data: any[], partial = false): Promise<void> {\n    const entry = this.seriesStore.get(seriesId);\n    if (!entry) throw new Error(`Series ${seriesId} not found`);\n    if (partial) {\n      // merge partial at the end\n      entry.data.splice(entry.data.length - data.length, data.length, ...data);\n    } else {\n      entry.data = data.slice();\n    }\n    this.seriesStore.set(seriesId, entry);\n    // emit update\n    this.emit('seriesUpdated', { seriesId, length: entry.data.length });\n    // render immediately on canvas renderer if available\n    const renderer = (this as any)._renderer;\n    if (renderer && typeof renderer.drawSeries === 'function') {\n      try {\n        renderer.drawSeries(seriesId, entry.data, Object.assign({}, entry.options, { startIndex: this.viewportStartIndex, visibleCount: this.viewportVisibleCount }));\n      } catch (e) { console.warn(e); }\n    }\n  }\n\n  private getDataLength(): number {\n    let max = 0;\n    for (const v of this.seriesStore.values()) {\n      if (v.data && v.data.length > max) max = v.data.length;\n    }\n    return max;\n  }\n\n  private createCanvas(): HTMLCanvasElement {\n    const c = document.createElement('canvas');\n    const w = ((this.options.width ?? this.container.clientWidth) || 800) as number;\n    const h = ((this.options.height ?? this.container.clientHeight) || 600) as number;\n    c.style.width = w + 'px';\n    c.style.height = h + 'px';\n    this.container.appendChild(c);\n    return c;\n  }\n\n  async updateSeries(seriesId: string, patch: { index: number; point: any }[]): Promise<void> {\n    const entry = this.seriesStore.get(seriesId);\n    if (!entry) throw new Error(`Series ${seriesId} not found`);\n    for (const p of patch) {\n      if (p.index < 0 || p.index >= entry.data.length) continue;\n      entry.data[p.index] = p.point;\n    }\n    this.emit('seriesUpdated', { seriesId, patch });\n  }\n\n  async pushRealtime(seriesId: string, point: any): Promise<void> {\n    const entry = this.seriesStore.get(seriesId);\n    if (!entry) throw new Error(`Series ${seriesId} not found`);\n    const last = entry.data[entry.data.length - 1];\n    if (!last || last.time !== point.time) {\n      entry.data.push(point);\n    } else {\n      // replace last\n      entry.data[entry.data.length - 1] = point;\n    }\n    this.emit('realtime', { seriesId, point });\n    this.emit('seriesUpdated', { seriesId, realtime: true });\n  }\n\n  getVisibleRange(): { from: number; to: number } | null {\n    const len = this.getDataLength();\n    if (len === 0) return null;\n    const from = Math.max(0, Math.min(len - 1, this.viewportStartIndex));\n    const to = Math.max(0, Math.min(len - 1, this.viewportStartIndex + this.viewportVisibleCount - 1));\n    return { from, to };\n  }\n\n  setVisibleRange(from: number, to: number): void {\n    // programmatic pan/zoom by indices\n    const len = this.getDataLength();\n    if (len === 0) return;\n    const f = Math.max(0, Math.min(len - 1, from));\n    const t = Math.max(0, Math.min(len - 1, to));\n    this.viewportStartIndex = Math.min(f, t);\n    this.viewportVisibleCount = Math.max(1, t - f + 1);\n    this.emit('rangeChanged', { from: this.viewportStartIndex, to: this.viewportStartIndex + this.viewportVisibleCount - 1 });\n    // force redraw of all series\n    const renderer = (this as any)._renderer;\n    if (renderer && typeof renderer.drawSeries === 'function') {\n      for (const [seriesId, entry] of this.seriesStore.entries()) {\n        try { renderer.drawSeries(seriesId, entry.data, Object.assign({}, entry.options, { startIndex: this.viewportStartIndex, visibleCount: this.viewportVisibleCount })); } catch (e) { console.warn(e); }\n      }\n    }\n  }\n\n  setViewport(fromIndex: number, toIndex: number): void {\n    this.setVisibleRange(fromIndex, toIndex);\n  }\n\n  panBy(deltaIndex: number): void {\n    const len = this.getDataLength();\n    if (len === 0) return;\n    const maxStart = Math.max(0, len - this.viewportVisibleCount);\n    this.viewportStartIndex = Math.max(0, Math.min(maxStart, this.viewportStartIndex + deltaIndex));\n    this.emit('rangeChanged', { from: this.viewportStartIndex, to: this.viewportStartIndex + this.viewportVisibleCount - 1 });\n    const renderer = (this as any)._renderer;\n    if (renderer && typeof renderer.drawSeries === 'function') {\n      for (const [seriesId, entry] of this.seriesStore.entries()) {\n        try { renderer.drawSeries(seriesId, entry.data, Object.assign({}, entry.options, { startIndex: this.viewportStartIndex, visibleCount: this.viewportVisibleCount })); } catch (e) { console.warn(e); }\n      }\n    }\n  }\n\n  zoomAt(factor: number, centerIndex?: number): void {\n    const len = this.getDataLength();\n    if (len === 0) return;\n    const minVisible = 5;\n    let newCount = Math.max(minVisible, Math.min(len, Math.round(this.viewportVisibleCount * factor)));\n    // determine center\n    const center = typeof centerIndex === 'number' ? centerIndex : Math.min(len - 1, this.viewportStartIndex + Math.floor(this.viewportVisibleCount / 2));\n    const rel = (center - this.viewportStartIndex) / Math.max(1, this.viewportVisibleCount - 1);\n    let newStart = center - Math.round(rel * (newCount - 1));\n    newStart = Math.max(0, Math.min(len - newCount, newStart));\n    this.viewportStartIndex = newStart;\n    this.viewportVisibleCount = newCount;\n    this.emit('rangeChanged', { from: this.viewportStartIndex, to: this.viewportStartIndex + this.viewportVisibleCount - 1 });\n    const renderer = (this as any)._renderer;\n    if (renderer && typeof renderer.drawSeries === 'function') {\n      for (const [seriesId, entry] of this.seriesStore.entries()) {\n        try { renderer.drawSeries(seriesId, entry.data, Object.assign({}, entry.options, { startIndex: this.viewportStartIndex, visibleCount: this.viewportVisibleCount })); } catch (e) { console.warn(e); }\n      }\n    }\n  }\n\n  applyOptions(options: ChartCoreOptions): void {\n    Object.assign(this.options, options);\n    this.emit('optionsChanged', this.options);\n  }\n\n  resize(): void {\n    // handle container resize\n    this.emit('resize');\n  }\n\n  async destroy(): Promise<void> {\n    // cleanup\n    await this.disconnectFeed();\n    this.seriesStore.clear();\n    this.listeners.clear();\n  }\n}\n\nimport type { ChartConfig, ChartOptions, IndicatorInstance, OhlcvPoint } from './types';\nimport type { ChartRenderer } from '../renderer/renderer';\nimport { WebGL2Renderer } from '../renderer/webgl2/webgl2Renderer';\nimport { WebGPURenderer } from '../renderer/webgpu/webgpuRenderer';\nimport type { IndicatorDefinition } from './indicatorTypes';\nimport { InMemoryIndicatorRegistry } from './indicators';\nimport { registerPhase1Indicators } from '../indicators/phase1';\nimport { registerPhase2Indicators } from '../indicators/phase2';\nimport { registerPhase3Indicators } from '../indicators/phase3';\nimport { registerPhase4Indicators } from '../indicators/phase4';\nimport { DEFAULT_MARKER_STYLES, type TradeMarker } from './tradeMarkers';\n\nexport class MoChart {\n  private renderer: ChartRenderer;\n  private data: OhlcvPoint[];\n  private config: ChartConfig;\n  private rafId: number | null = null;\n  private registry = new InMemoryIndicatorRegistry();\n  private indicatorInstances: IndicatorInstance[] = [];\n  private tradeMarkers: TradeMarker[] = [];\n  private alertCallbacks: Array<(alert: { indicatorId: string; alertId: string; message: string }) => void> = [];\n  private lastAlertAt = new Map<string, number>();\n\n  constructor(canvas: HTMLCanvasElement, options: ChartOptions) {\n    this.data = options.data;\n    this.config = options.config ?? {};\n    this.indicatorInstances = this.config.indicators ?? [];\n    this.tradeMarkers = this.config.tradeMarkers ?? [];\n\n    registerPhase1Indicators(this.registry);\n    registerPhase2Indicators(this.registry);\n    registerPhase3Indicators(this.registry);\n    registerPhase4Indicators(this.registry);\n\n    this.renderer = 'gpu' in navigator ? new WebGPURenderer() : new WebGL2Renderer();\n    this.renderer.initialize(canvas);\n    this.renderer.setConfig(this.config);\n    this.renderer.setData(this.data);\n    this.rebuildIndicatorSegments();\n\n    this.start();\n  }\n\n  start(): void {\n    const tick = () => {\n      this.renderer.render();\n      this.rafId = requestAnimationFrame(tick);\n    };\n\n    if (this.rafId === null) {\n      this.rafId = requestAnimationFrame(tick);\n    }\n  }\n\n  stop(): void {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  }\n\n  setData(data: OhlcvPoint[]): void {\n    this.data = data;\n    this.renderer.setData(data);\n    this.rebuildIndicatorSegments();\n  }\n\n  setConfig(config: ChartConfig): void {\n    this.config = config;\n    this.indicatorInstances = config.indicators ?? [];\n    this.tradeMarkers = config.tradeMarkers ?? [];\n    this.renderer.setConfig(config);\n    this.rebuildIndicatorSegments();\n  }\n\n  registerIndicator<T>(definition: IndicatorDefinition<T>): void {\n    this.registry.register(definition);\n  }\n\n  addIndicator(id: string, params?: Record<string, unknown>): string {\n    const instanceId = `ind_${crypto.randomUUID()}`;\n    this.indicatorInstances = [\n      ...this.indicatorInstances,\n      { id, instanceId, params, enabled: true },\n    ];\n    this.setConfig({ ...this.config, indicators: this.indicatorInstances });\n    return instanceId;\n  }\n\n  removeIndicator(instanceId: string): void {\n    this.indicatorInstances = this.indicatorInstances.filter((ind) => ind.instanceId !== instanceId);\n    this.setConfig({ ...this.config, indicators: this.indicatorInstances });\n  }\n\n  updateParams(instanceId: string, params: Record<string, unknown>): void {\n    this.indicatorInstances = this.indicatorInstances.map((ind) =>\n      ind.instanceId === instanceId ? { ...ind, params } : ind\n    );\n    this.setConfig({ ...this.config, indicators: this.indicatorInstances });\n  }\n\n  toggleVisibility(instanceId: string): void {\n    this.indicatorInstances = this.indicatorInstances.map((ind) =>\n      ind.instanceId === instanceId ? { ...ind, enabled: !ind.enabled } : ind\n    );\n    this.setConfig({ ...this.config, indicators: this.indicatorInstances });\n  }\n\n  getActiveIndicators(): IndicatorInstance[] {\n    return this.indicatorInstances;\n  }\n\n  addTradeMarkers(markers: TradeMarker[]): void {\n    this.tradeMarkers = [...this.tradeMarkers, ...markers];\n    this.setConfig({ ...this.config, tradeMarkers: this.tradeMarkers });\n  }\n\n  clearTradeMarkers(): void {\n    this.tradeMarkers = [];\n    this.setConfig({ ...this.config, tradeMarkers: [] });\n  }\n\n  onAlert(callback: (alert: { indicatorId: string; alertId: string; message: string }) => void): () => void {\n    this.alertCallbacks.push(callback);\n    return () => {\n      this.alertCallbacks = this.alertCallbacks.filter((cb) => cb !== callback);\n    };\n  }\n\n  private rebuildIndicatorSegments(): void {\n    const segments = this.computeIndicatorSegments();\n    this.renderer.setIndicatorSegments(segments);\n    void this.rebuildIndicatorSegmentsGPU();\n  }\n\n  private async rebuildIndicatorSegmentsGPU(): Promise<void> {\n    if (!(this.renderer instanceof WebGPURenderer)) return;\n    const segments = await this.computeIndicatorSegmentsGPU(this.renderer);\n    if (segments.length) {\n      this.renderer.setIndicatorSegments(segments);\n    }\n  }\n\n  private computeIndicatorSegments(): Float32Array {\n    if (!this.data.length || this.indicatorInstances.length === 0) {\n      return new Float32Array();\n    }\n\n    const count = this.data.length;\n    const step = 2 / Math.max(1, count - 1);\n    const toX = (i: number) => -1 + step * i;\n\n    const mainRange = {\n      min: Math.min(...this.data.map((d) => d.low)),\n      max: Math.max(...this.data.map((d) => d.high)),\n    };\n    const subRanges: Record<'sub1' | 'sub2' | 'sub3', { min: number; max: number }> = {\n      sub1: { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },\n      sub2: { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },\n      sub3: { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },\n    };\n    const paneLayout: Record<'main' | 'sub1' | 'sub2' | 'sub3', { top: number; height: number }> = {\n      main: { top: 0, height: 0.6 },\n      sub1: { top: 0.6, height: 0.15 },\n      sub2: { top: 0.75, height: 0.15 },\n      sub3: { top: 0.9, height: 0.1 },\n    };\n\n    const updateRange = (pane: 'sub1' | 'sub2' | 'sub3', value: number) => {\n      const range = subRanges[pane];\n      range.min = Math.min(range.min, value);\n      range.max = Math.max(range.max, value);\n    };\n\n    for (const instance of this.indicatorInstances) {\n      if (instance.enabled === false) continue;\n      const def = this.registry.get(instance.id);\n      if (!def || def.pane === 'main') continue;\n      const params = (instance.params ?? {}) as any;\n      const result = def.calculate(this.data, params);\n      if (!result.ok) continue;\n      for (const output of def.outputs) {\n        const series = result.value[output.name];\n        if (!series) continue;\n        for (const value of series) {\n          if (value == null) continue;\n          updateRange(def.pane, value);\n        }\n      }\n    }\n\n    const normalizeRange = (pane: 'sub1' | 'sub2' | 'sub3') => {\n      const range = subRanges[pane];\n      if (!Number.isFinite(range.min) || !Number.isFinite(range.max)) {\n        range.min = 0;\n        range.max = 1;\n      }\n      if (range.min === range.max) {\n        range.min -= 1;\n        range.max += 1;\n      }\n    };\n\n    normalizeRange('sub1');\n    normalizeRange('sub2');\n    normalizeRange('sub3');\n\n    const toPaneY = (pane: 'main' | 'sub1' | 'sub2' | 'sub3', value: number) => {\n      const layout = paneLayout[pane];\n      const topNdc = 1 - 2 * layout.top;\n      const bottomNdc = 1 - 2 * (layout.top + layout.height);\n      let min = mainRange.min;\n      let max = mainRange.max;\n      if (pane !== 'main') {\n        min = subRanges[pane].min;\n        max = subRanges[pane].max;\n      }\n      const ratio = (value - min) / (max - min);\n      return bottomNdc + (topNdc - bottomNdc) * ratio;\n    };\n\n    const vertices: number[] = [];\n\n    for (const instance of this.indicatorInstances) {\n      if (instance.enabled === false) continue;\n      const def = this.registry.get(instance.id);\n      if (!def || def.pane !== 'main') continue;\n      const params = (instance.params ?? {}) as any;\n      const result = def.calculate(this.data, params);\n      if (!result.ok) continue;\n\n      for (const output of def.outputs) {\n        if (output.style !== 'line') continue;\n        const series = result.value[output.name];\n        if (!series) continue;\n        const color = this.parseColor(output.color);\n        for (let i = 1; i < series.length; i++) {\n          const prev = series[i - 1];\n          const cur = series[i];\n          if (prev == null || cur == null) continue;\n          const x0 = toX(i - 1);\n          const y0 = toPaneY('main', prev);\n          const x1 = toX(i);\n          const y1 = toPaneY('main', cur);\n          vertices.push(x0, y0, ...color);\n          vertices.push(x1, y1, ...color);\n        }\n      }\n\n      this.evaluateAlerts(def, result.value, this.data[this.data.length - 1]);\n    }\n\n    for (const instance of this.indicatorInstances) {\n      if (instance.enabled === false) continue;\n      const def = this.registry.get(instance.id);\n      if (!def || def.pane === 'main') continue;\n      const params = (instance.params ?? {}) as any;\n      const result = def.calculate(this.data, params);\n      if (!result.ok) continue;\n\n      for (const output of def.outputs) {\n        const series = result.value[output.name];\n        if (!series) continue;\n        const color = this.parseColor(output.color);\n        if (output.style === 'line') {\n          for (let i = 1; i < series.length; i++) {\n            const prev = series[i - 1];\n            const cur = series[i];\n            if (prev == null || cur == null) continue;\n            const x0 = toX(i - 1);\n            const y0 = toPaneY(def.pane, prev);\n            const x1 = toX(i);\n            const y1 = toPaneY(def.pane, cur);\n            vertices.push(x0, y0, ...color);\n            vertices.push(x1, y1, ...color);\n          }\n        } else if (output.style === 'histogram' || output.style === 'bar') {\n          const baseY = toPaneY(def.pane, 0);\n          for (let i = 0; i < series.length; i++) {\n            const value = series[i];\n            if (value == null) continue;\n            const x = toX(i);\n            const y = toPaneY(def.pane, value);\n            vertices.push(x, baseY, ...color);\n            vertices.push(x, y, ...color);\n          }\n        }\n        if (output.style === 'marker') {\n          for (let i = 0; i < series.length; i++) {\n            const value = series[i];\n            if (value == null) continue;\n            const x = toX(i);\n            const y = toPaneY(def.pane, value);\n            this.pushMarkerShape(vertices, x, y, 0.01, 'diamond', color);\n          }\n        }\n      }\n    }\n\n    if (this.tradeMarkers.length) {\n      const markerSize = 0.01;\n      for (const marker of this.tradeMarkers) {\n        const index = this.findNearestIndex(marker.time);\n        if (index < 0) continue;\n        const x = toX(index);\n        const y = toPaneY('main', marker.price);\n        const style = DEFAULT_MARKER_STYLES[marker.type];\n        const color = this.parseColor(style.color);\n        const size = (marker.size ?? style.size) * markerSize;\n        this.pushMarkerShape(vertices, x, y, size, style.shape, color);\n      }\n    }\n\n    return new Float32Array(vertices);\n  }\n\n  private async computeIndicatorSegmentsGPU(renderer: WebGPURenderer): Promise<Float32Array> {\n    if (!this.data.length || this.indicatorInstances.length === 0) {\n      return new Float32Array();\n    }\n\n    const count = this.data.length;\n    const step = 2 / Math.max(1, count - 1);\n    const toX = (i: number) => -1 + step * i;\n\n    const mainRange = {\n      min: Math.min(...this.data.map((d) => d.low)),\n      max: Math.max(...this.data.map((d) => d.high)),\n    };\n    const subRanges: Record<'sub1' | 'sub2' | 'sub3', { min: number; max: number }> = {\n      sub1: { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },\n      sub2: { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },\n      sub3: { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },\n    };\n    const paneLayout: Record<'main' | 'sub1' | 'sub2' | 'sub3', { top: number; height: number }> = {\n      main: { top: 0, height: 0.6 },\n      sub1: { top: 0.6, height: 0.15 },\n      sub2: { top: 0.75, height: 0.15 },\n      sub3: { top: 0.9, height: 0.1 },\n    };\n\n    const updateRange = (pane: 'sub1' | 'sub2' | 'sub3', value: number) => {\n      const range = subRanges[pane];\n      range.min = Math.min(range.min, value);\n      range.max = Math.max(range.max, value);\n    };\n\n    const dataBuffer = new Float32Array(this.data.length * 6);\n    this.data.forEach((bar, i) => {\n      const offset = i * 6;\n      dataBuffer[offset + 0] = bar.time;\n      dataBuffer[offset + 1] = bar.open;\n      dataBuffer[offset + 2] = bar.high;\n      dataBuffer[offset + 3] = bar.low;\n      dataBuffer[offset + 4] = bar.close;\n      dataBuffer[offset + 5] = bar.volume;\n    });\n\n    const computeOutputs = new Map<string, Record<string, (number | null)[]>>();\n    const inputBuffer = renderer.createInputBuffer(dataBuffer);\n\n    const orderedInstances = this.orderInstancesByDependencies();\n\n    for (const instance of orderedInstances) {\n      if (instance.enabled === false) continue;\n      const def = this.registry.get(instance.id);\n      if (!def || !def.wgslSource) continue;\n      const params = (instance.params ?? {}) as Record<string, number>;\n      const seriesCount = def.outputs.length;\n      const paramBuffer = this.buildUniformParams(def.id, params, this.data.length);\n      const output = await renderer.computeIndicatorGPUWithInput(\n        def.wgslSource,\n        paramBuffer,\n        inputBuffer,\n        this.data.length * seriesCount,\n        this.data.length\n      );\n      if (!output) continue;\n      const seriesMap: Record<string, (number | null)[]> = {};\n      for (let s = 0; s < seriesCount; s++) {\n        const name = def.outputs[s].name;\n        seriesMap[name] = [];\n      }\n      for (let i = 0; i < this.data.length; i++) {\n        for (let s = 0; s < seriesCount; s++) {\n          const value = output[i * seriesCount + s];\n          seriesMap[def.outputs[s].name].push(Number.isNaN(value) ? null : value);\n        }\n      }\n      computeOutputs.set(instance.instanceId, seriesMap);\n    }\n\n    for (const instance of this.indicatorInstances) {\n      if (instance.enabled === false) continue;\n      const def = this.registry.get(instance.id);\n      if (!def || def.pane === 'main') continue;\n      const series = computeOutputs.get(instance.instanceId);\n      if (!series) continue;\n      for (const output of def.outputs) {\n        const values = series[output.name];\n        if (!values) continue;\n        for (const value of values) {\n          if (value == null) continue;\n          updateRange(def.pane, value);\n        }\n      }\n    }\n\n    const normalizeRange = (pane: 'sub1' | 'sub2' | 'sub3') => {\n      const range = subRanges[pane];\n      if (!Number.isFinite(range.min) || !Number.isFinite(range.max)) {\n        range.min = 0;\n        range.max = 1;\n      }\n      if (range.min === range.max) {\n        range.min -= 1;\n        range.max += 1;\n      }\n    };\n\n    normalizeRange('sub1');\n    normalizeRange('sub2');\n    normalizeRange('sub3');\n\n    const toPaneY = (pane: 'main' | 'sub1' | 'sub2' | 'sub3', value: number) => {\n      const layout = paneLayout[pane];\n      const topNdc = 1 - 2 * layout.top;\n      const bottomNdc = 1 - 2 * (layout.top + layout.height);\n      let min = mainRange.min;\n      let max = mainRange.max;\n      if (pane !== 'main') {\n        min = subRanges[pane].min;\n        max = subRanges[pane].max;\n      }\n      const ratio = (value - min) / (max - min);\n      return bottomNdc + (topNdc - bottomNdc) * ratio;\n    };\n\n    const vertices: number[] = [];\n\n    for (const instance of this.indicatorInstances) {\n      if (instance.enabled === false) continue;\n      const def = this.registry.get(instance.id);\n      if (!def) continue;\n      const series = computeOutputs.get(instance.instanceId);\n      if (!series) continue;\n      for (const output of def.outputs) {\n        const values = series[output.name];\n        if (!values) continue;\n        const color = this.parseColor(output.color);\n        if (output.style === 'line') {\n          for (let i = 1; i < values.length; i++) {\n            const prev = values[i - 1];\n            const cur = values[i];\n            if (prev == null || cur == null) continue;\n            const x0 = toX(i - 1);\n            const y0 = toPaneY(def.pane, prev);\n            const x1 = toX(i);\n            const y1 = toPaneY(def.pane, cur);\n            vertices.push(x0, y0, ...color);\n            vertices.push(x1, y1, ...color);\n          }\n        } else if (output.style === 'histogram' || output.style === 'bar') {\n          const baseY = toPaneY(def.pane, 0);\n          for (let i = 0; i < values.length; i++) {\n            const value = values[i];\n            if (value == null) continue;\n            const x = toX(i);\n            const y = toPaneY(def.pane, value);\n            vertices.push(x, baseY, ...color);\n            vertices.push(x, y, ...color);\n          }\n        }\n        if (output.style === 'marker') {\n          for (let i = 0; i < values.length; i++) {\n            const value = values[i];\n            if (value == null) continue;\n            const x = toX(i);\n            const y = toPaneY(def.pane, value);\n            this.pushMarkerShape(vertices, x, y, 0.01, 'diamond', color);\n          }\n        }\n      }\n      this.evaluateAlerts(def, series, this.data[this.data.length - 1]);\n    }\n\n    return new Float32Array(vertices);\n  }\n\n  private orderInstancesByDependencies(): IndicatorInstance[] {\n    const ids = Array.from(new Set(this.indicatorInstances.map((ind) => ind.id)));\n    let orderedIds: string[] = [];\n    try {\n      orderedIds = this.registry.resolveDependencies(ids).map((def) => def.id);\n    } catch {\n      orderedIds = ids;\n    }\n    const orderMap = new Map<string, number>();\n    orderedIds.forEach((id, index) => orderMap.set(id, index));\n    return [...this.indicatorInstances].sort(\n      (a, b) => (orderMap.get(a.id) ?? 0) - (orderMap.get(b.id) ?? 0)\n    );\n  }\n\n  private buildUniformParams(id: string, params: Record<string, number>, dataLen: number): ArrayBuffer {\n    const buffer = new ArrayBuffer(16);\n    const view = new DataView(buffer);\n    const setU32 = (offset: number, value: number) => view.setUint32(offset, value, true);\n    const setF32 = (offset: number, value: number) => view.setFloat32(offset, value, true);\n\n    switch (id) {\n      case 'bb':\n      case 'percent_b':\n      case 'bb_width':\n        setU32(0, params.period ?? 20);\n        setF32(4, params.stdDev ?? 2);\n        setU32(8, dataLen);\n        return buffer;\n      case 'macd':\n        setU32(0, params.fastPeriod ?? 12);\n        setU32(4, params.slowPeriod ?? 26);\n        setU32(8, params.signalPeriod ?? 9);\n        setU32(12, dataLen);\n        return buffer;\n      case 'adx':\n      case 'atr':\n      case 'rsi':\n      case 'sma':\n      case 'ema':\n      case 'vwap':\n      case 'vol_ratio':\n      default:\n        setU32(0, params.period ?? 14);\n        setU32(4, dataLen);\n        return buffer;\n    }\n  }\n\n  private parseColor(color: string): [number, number, number, number] {\n    if (color.startsWith('#')) {\n      const hex = color.replace('#', '');\n      const val = parseInt(hex.length === 3 ? hex.split('').map((c) => c + c).join('') : hex, 16);\n      const r = ((val >> 16) & 255) / 255;\n      const g = ((val >> 8) & 255) / 255;\n      const b = (val & 255) / 255;\n      return [r, g, b, 1];\n    }\n    const rgba = color.match(/rgba?\\(([^)]+)\\)/i);\n    if (rgba) {\n      const parts = rgba[1].split(',').map((p) => parseFloat(p.trim()));\n      const [r, g, b, a = 1] = parts;\n      return [r / 255, g / 255, b / 255, a];\n    }\n    return [1, 1, 1, 1];\n  }\n\n  private evaluateAlerts(\n    def: IndicatorDefinition<any, any>,\n    series: Record<string, number | null | (number | null)[]>,\n    bar: OhlcvPoint\n  ) {\n    if (!def.alerts || def.alerts.length === 0) return;\n    const lastIndex = this.data.length - 1;\n    const values: Record<string, number | null> = {};\n    const prevValues: Record<string, number | null> = {};\n\n    for (const output of def.outputs) {\n      const outputSeries = series[output.name] as (number | null)[] | undefined;\n      if (!outputSeries) continue;\n      values[output.name] = outputSeries[lastIndex] ?? null;\n      prevValues[output.name] = outputSeries[lastIndex - 1] ?? null;\n    }\n\n    for (const alert of def.alerts) {\n      const key = `${def.id}:${alert.id}`;\n      const lastAt = this.lastAlertAt.get(key) ?? 0;\n      const now = Date.now();\n      if (alert.cooldown && now - lastAt < alert.cooldown * 1000) continue;\n      if (alert.condition(values, bar, prevValues)) {\n        const message = alert.message(values, bar);\n        this.lastAlertAt.set(key, now);\n        this.alertCallbacks.forEach((cb) => cb({ indicatorId: def.id, alertId: alert.id, message }));\n      }\n    }\n  }\n\n  private findNearestIndex(time: number): number {\n    let best = -1;\n    let bestDiff = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < this.data.length; i++) {\n      const diff = Math.abs(this.data[i].time - time);\n      if (diff < bestDiff) {\n        bestDiff = diff;\n        best = i;\n      }\n    }\n    return best;\n  }\n\n  private pushMarkerShape(\n    out: number[],\n    x: number,\n    y: number,\n    size: number,\n    shape: 'triangle_up' | 'triangle_down' | 'circle' | 'cross' | 'diamond' | 'warning',\n    color: [number, number, number, number]\n  ) {\n    const line = (x0: number, y0: number, x1: number, y1: number) => {\n      out.push(x0, y0, ...color);\n      out.push(x1, y1, ...color);\n    };\n\n    switch (shape) {\n      case 'triangle_up': {\n        const top = [x, y + size];\n        const left = [x - size, y - size];\n        const right = [x + size, y - size];\n        line(top[0], top[1], left[0], left[1]);\n        line(left[0], left[1], right[0], right[1]);\n        line(right[0], right[1], top[0], top[1]);\n        break;\n      }\n      case 'triangle_down': {\n        const bottom = [x, y - size];\n        const left = [x - size, y + size];\n        const right = [x + size, y + size];\n        line(bottom[0], bottom[1], left[0], left[1]);\n        line(left[0], left[1], right[0], right[1]);\n        line(right[0], right[1], bottom[0], bottom[1]);\n        break;\n      }\n      case 'diamond': {\n        const top = [x, y + size];\n        const right = [x + size, y];\n        const bottom = [x, y - size];\n        const left = [x - size, y];\n        line(top[0], top[1], right[0], right[1]);\n        line(right[0], right[1], bottom[0], bottom[1]);\n        line(bottom[0], bottom[1], left[0], left[1]);\n        line(left[0], left[1], top[0], top[1]);\n        break;\n      }\n      case 'circle': {\n        const segments = 12;\n        for (let i = 0; i < segments; i++) {\n          const a0 = (i / segments) * Math.PI * 2;\n          const a1 = ((i + 1) / segments) * Math.PI * 2;\n          const x0 = x + Math.cos(a0) * size;\n          const y0 = y + Math.sin(a0) * size;\n          const x1 = x + Math.cos(a1) * size;\n          const y1 = y + Math.sin(a1) * size;\n          line(x0, y0, x1, y1);\n        }\n        break;\n      }\n      case 'warning': {\n        const top = [x, y + size];\n        const left = [x - size, y - size];\n        const right = [x + size, y - size];\n        line(top[0], top[1], left[0], left[1]);\n        line(left[0], left[1], right[0], right[1]);\n        line(right[0], right[1], top[0], top[1]);\n        line(x, y - size * 0.2, x, y + size * 0.4);\n        line(x, y - size * 0.6, x, y - size * 0.55);\n        break;\n      }\n      case 'cross':\n      default: {\n        line(x - size, y, x + size, y);\n        line(x, y - size, x, y + size);\n      }\n    }\n  }\n\n  destroy(): void {\n    this.stop();\n    this.renderer.destroy();\n  }\n}\n",
    "// Embed API for external integrations (Next.js friendly, SSR-safe)\nimport type { ChartCore, ChartCoreOptions } from './chart';\n\nexport type EventHandler = (payload?: any) => void;\n\nexport interface ChartEmbedAPI {\n  create(container: HTMLElement, options?: ChartCoreOptions): Promise<ChartCore>;\n  connectFeed(adapter: any): Promise<void>;\n  disconnectFeed(): Promise<void>;\n  on(event: string, handler: EventHandler): void;\n  off(event: string, handler?: EventHandler): void;\n  destroy(): Promise<void>;\n}\n\n// Factory that returns a minimal API object. Implementation lives in src/core/chart.ts\nexport function createEmbedAPI(): ChartEmbedAPI {\n  // Concrete embed API implementation: owns DOM event wiring and tooltip\n  class ChartEmbed implements ChartEmbedAPI {\n    private core: ChartCore | null = null;\n    private container: HTMLElement | null = null;\n    private handlers: Map<string, Set<EventHandler>> = new Map();\n    private tooltipEl: HTMLElement | null = null;\n    private legendEl: HTMLElement | null = null;\n    private pointerId: number | null = null;\n    private dragging = false;\n    private dragStartX = 0;\n    private dragStartIndex = 0;\n    private opts: any = {};\n    // touch pinch state\n    private _pinchStartDist: number | null = null;\n    private _pinchStartCenterClientX: number | null = null;\n    private _pinchStartCenterIndex: number | undefined = undefined;\n\n    async create(container: HTMLElement, options?: any): Promise<ChartCore> {\n      const mod = await import('./chart');\n      this.container = container;\n      this.opts = options ?? {};\n      this.core = new mod.ChartCore(container, options);\n      // proxy core events\n      this.core.on('rangeChanged', (p) => this.emit('rangeChanged', p));\n      this.core.on('seriesUpdated', (p) => this.emit('seriesUpdated', p));\n      // attach DOM events if requested\n      if (this.opts.attachEvents !== false) this.attachEvents();\n      if (this.opts.enableTooltip) this.enableTooltip(true);\n      if (this.opts.showLegend) this._ensureLegend();\n      return this.core;\n    }\n\n    private getCanvas(): HTMLCanvasElement | null {\n      if (!this.container) return null;\n      if (this.container.tagName.toLowerCase() === 'canvas') return this.container as unknown as HTMLCanvasElement;\n      const c = this.container.querySelector('canvas');\n      return c as HTMLCanvasElement | null;\n    }\n\n    private attachEvents() {\n      const canvas = this.getCanvas();\n      if (!canvas || !this.core) return;\n      const renderer = (this.core as any)._renderer as any;\n      if (!renderer) return;\n\n      const onPointerDown = (ev: PointerEvent) => {\n        canvas.setPointerCapture(ev.pointerId);\n        this.pointerId = ev.pointerId;\n        this.dragging = true;\n        this.dragStartX = ev.clientX;\n        const vr = this.core!.getVisibleRange();\n        this.dragStartIndex = vr ? vr.from : 0;\n      };\n\n      const onPointerMove = (ev: PointerEvent) => {\n        if (!this.core) return;\n        if (this.dragging) {\n          const seriesStore = (this.core as any).seriesStore as any;\n          const primaryEntry = seriesStore ? Array.from(seriesStore.values())[0] as any : null;\n          const primaryData = primaryEntry?.data ?? [];\n          const layout = renderer.getLayout ? renderer.getLayout(primaryData, this.opts) : null;\n          const stepX = layout ? layout.stepX : 10;\n          const dx = ev.clientX - this.dragStartX;\n          const deltaIndex = Math.round(-dx / stepX);\n          this.core!.panBy(deltaIndex + (this.dragStartIndex - (this.core!.getVisibleRange()?.from ?? 0)));\n          return;\n        }\n        // hover: show tooltip only when over a candle (not just anywhere on plot)\n        if (this.tooltipEl && this.opts.enableTooltip) {\n          const rect = canvas.getBoundingClientRect();\n          const mx = ev.clientX - rect.left;\n          const my = ev.clientY - rect.top;\n          const seriesStore = (this.core as any).seriesStore as any;\n          const primaryEntry = seriesStore ? Array.from(seriesStore.values())[0] as any : null;\n          const data = primaryEntry?.data ?? [];\n          const mapped = renderer.mapClientToData(mx, my, data, this.opts);\n          if (!mapped) { this.tooltipEl.style.display = 'none'; return; }\n          // determine candle hit by using layout and candle width\n          const layout = renderer.getLayout ? renderer.getLayout(data, this.opts) : null;\n          const candleW = layout ? layout.candleW : (layout ? layout.candleW : 10);\n          const dx = Math.abs(mx - mapped.x);\n          const horizHit = dx <= (candleW / 2 + 4); // horizontal tolerance in px\n          // vertical hit: compute candle Y positions from layout yMin/yMax\n          let vertHit = true;\n          if (layout && typeof layout.yMin === 'number' && typeof layout.yMax === 'number') {\n            const { plotY, plotH, yMin, yMax } = layout as any;\n            const priceToY = (p: number) => {\n              const t = (p - yMin) / (yMax - yMin || 1);\n              return plotY + (1 - t) * plotH;\n            };\n            const yOpen = priceToY(mapped.point.open);\n            const yClose = priceToY(mapped.point.close);\n            const yHigh = priceToY(mapped.point.high);\n            const yLow = priceToY(mapped.point.low);\n            const top = Math.min(yOpen, yClose, yHigh);\n            const bottom = Math.max(yOpen, yClose, yLow);\n            const vertTol = 6; // px tolerance\n            vertHit = (my >= top - vertTol && my <= bottom + vertTol);\n          }\n          if (!(horizHit && vertHit)) { this.tooltipEl.style.display = 'none'; return; }\n\n          // format tooltip with OHLCV each on its own line\n          const p = mapped.point;\n          const html = this.opts.tooltipFormatter ? this.opts.tooltipFormatter(p, mapped.index) : `<div style=\"font-weight:600\">${new Date(mapped.time).toLocaleDateString()}</div><div>O ${p.open}</div><div>H ${p.high}</div><div>L ${p.low}</div><div>C ${p.close}</div><div>V ${p.volume.toLocaleString()}</div>`;\n          this.tooltipEl.innerHTML = html;\n\n          // position tooltip relative to the container (use client coordinates)\n          const containerRect = this.container!.getBoundingClientRect();\n          // temporarily make visible to measure\n          this.tooltipEl.style.display = 'block';\n          this.tooltipEl.style.left = '0px';\n          this.tooltipEl.style.top = '0px';\n          const tipRect = this.tooltipEl.getBoundingClientRect();\n          const tipW = tipRect.width;\n          const tipH = tipRect.height;\n          // client coords relative to container\n          const clientXRel = ev.clientX - containerRect.left;\n          const clientYRel = ev.clientY - containerRect.top;\n          // default place to right-bottom of cursor\n          let left = clientXRel + 12;\n          let top = clientYRel + 12;\n          // if cursor is in lower half of canvas, show above cursor\n          const canvasMidY = rect.height / 2;\n          if (ev.clientY - rect.top > canvasMidY) {\n            top = clientYRel - tipH - 12;\n          }\n          // avoid right overflow relative to container\n          if (left + tipW > containerRect.width - 6) left = Math.max(6, clientXRel - tipW - 12);\n          if (left < 6) left = 6;\n          if (top < 6) top = 6;\n          this.tooltipEl.style.left = left + 'px';\n          this.tooltipEl.style.top = top + 'px';\n\n          // draw crosshair: redraw base then overlay crosshair\n          const primarySeriesId = Array.from((this.core as any).seriesStore.keys())[0];\n          const entry = (this.core as any).seriesStore.get(primarySeriesId) as any;\n          if (renderer && typeof renderer.drawSeries === 'function') {\n            const vr = this.core!.getVisibleRange();\n            if (vr && typeof vr.from === 'number' && typeof vr.to === 'number') {\n              renderer.drawSeries(primarySeriesId, entry?.data ?? [], Object.assign({}, entry?.options ?? {}, { startIndex: vr.from, visibleCount: vr.to - vr.from + 1 }));\n            } else {\n              renderer.drawSeries(primarySeriesId, entry?.data ?? [], Object.assign({}, entry?.options ?? {}));\n            }\n            renderer.drawCrosshairAt(mx, my, entry?.data ?? [], this.opts);\n          }\n          // update legend with hovered point\n          if (this.legendEl) {\n            this._updateLegend(`${this.opts.symbol ?? ''}`, `C ${p.close}` + ` (${new Date(mapped.time).toLocaleDateString()})`);\n          }\n        }\n      };\n\n      const onPointerUp = (ev: PointerEvent) => {\n        try { canvas.releasePointerCapture(ev.pointerId); } catch {};\n        this.dragging = false; this.pointerId = null;\n      };\n\n      const onWheel = (ev: WheelEvent) => {\n        ev.preventDefault();\n        if (!this.core) return;\n        const rect = canvas.getBoundingClientRect();\n        const cx = ev.clientX - rect.left;\n        const mx = cx;\n        const mapped = renderer.mapClientToData(mx, rect.height / 2, this._getPrimarySeriesData(), this.opts);\n        const centerIndex = mapped ? mapped.index : undefined;\n        const factor = ev.deltaY < 0 ? 1 / 1.15 : 1.15;\n        this.core.zoomAt(factor, centerIndex);\n      };\n\n      // touch events: support pinch-zoom\n      const onTouchStart = (ev: TouchEvent) => {\n        if (!canvas || !this.core) return;\n        if (ev.touches.length === 2) {\n          ev.preventDefault();\n          const t0 = ev.touches[0];\n          const t1 = ev.touches[1];\n          const dx = t1.clientX - t0.clientX;\n          const dy = t1.clientY - t0.clientY;\n          this._pinchStartDist = Math.hypot(dx, dy);\n          this._pinchStartCenterClientX = (t0.clientX + t1.clientX) / 2 - canvas.getBoundingClientRect().left;\n          const mapped = renderer.mapClientToData(this._pinchStartCenterClientX, (canvas.height / (window.devicePixelRatio || 1)) / 2, this._getPrimarySeriesData(), this.opts);\n          this._pinchStartCenterIndex = mapped ? mapped.index : undefined;\n        }\n      };\n\n      const onTouchMove = (ev: TouchEvent) => {\n        if (!canvas || !this.core) return;\n        if (ev.touches.length === 2 && this._pinchStartDist) {\n          ev.preventDefault();\n          const t0 = ev.touches[0];\n          const t1 = ev.touches[1];\n          const dx = t1.clientX - t0.clientX;\n          const dy = t1.clientY - t0.clientY;\n          const dist = Math.hypot(dx, dy);\n          const factor = this._pinchStartDist > 0 ? dist / this._pinchStartDist : 1;\n          const clamped = Math.max(0.5, Math.min(2.5, factor));\n          this.core.zoomAt(1 / clamped, this._pinchStartCenterIndex);\n        }\n      };\n\n      const onTouchEnd = (ev: TouchEvent) => {\n        if (ev.touches.length < 2) {\n          this._pinchStartDist = null;\n          this._pinchStartCenterClientX = null;\n          this._pinchStartCenterIndex = undefined;\n        }\n      };\n\n      canvas.addEventListener('pointerdown', onPointerDown);\n      canvas.addEventListener('pointermove', onPointerMove);\n      window.addEventListener('pointerup', onPointerUp);\n      canvas.addEventListener('wheel', onWheel, { passive: false });\n      canvas.addEventListener('touchstart', onTouchStart, { passive: false });\n      canvas.addEventListener('touchmove', onTouchMove, { passive: false });\n      canvas.addEventListener('touchend', onTouchEnd);\n\n      // store listeners for later detach\n      (this as any)._listeners = { onPointerDown, onPointerMove, onPointerUp, onWheel, onTouchStart, onTouchMove, onTouchEnd };\n    }\n\n    private _getPrimarySeriesData() {\n      if (!this.core) return [];\n      const keys = Array.from((this.core as any).seriesStore.keys());\n      if (keys.length === 0) return [];\n      const entry = (this.core as any).seriesStore.get(keys[0]);\n      return entry?.data ?? [];\n    }\n\n    enableTooltip(v: boolean) {\n      this.opts.enableTooltip = !!v;\n      if (!this.container) return;\n      if (v) {\n        if (!this.tooltipEl) this.tooltipEl = this._createTooltip();\n        this.tooltipEl.style.display = 'none';\n      } else {\n        if (this.tooltipEl) this.tooltipEl.style.display = 'none';\n      }\n    }\n\n    private _ensureLegend() {\n      if (!this.container) return;\n      if (!this.legendEl) this.legendEl = this._createLegend();\n      // update initial content\n      this._updateLegend(this.opts.symbol ?? '', '');\n    }\n\n    private _createLegend() {\n      if (!this.container) throw new Error('No container');\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '8px';\n      div.style.top = '8px';\n      div.style.pointerEvents = 'none';\n      div.style.background = 'rgba(255,255,255,0.85)';\n      div.style.color = '#000';\n      div.style.padding = '6px 8px';\n      div.style.borderRadius = '4px';\n      div.style.font = '12px sans-serif';\n      div.style.zIndex = '900';\n      this.container.appendChild(div);\n      return div;\n    }\n\n    private _updateLegend(left: string, right: string) {\n      if (!this.legendEl) return;\n      this.legendEl.innerHTML = `<div style=\"font-weight:600\">${left}</div><div style=\"opacity:0.85\">${right}</div>`;\n    }\n\n    private _createTooltip() {\n      if (!this.container) throw new Error('No container');\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.pointerEvents = 'none';\n      div.style.background = 'rgba(0,0,0,0.8)';\n      div.style.color = '#fff';\n      div.style.padding = '6px 8px';\n      div.style.borderRadius = '4px';\n      div.style.font = '12px sans-serif';\n      div.style.display = 'none';\n      div.style.zIndex = '1000';\n      this.container.appendChild(div);\n      return div;\n    }\n\n    on(event: string, handler: EventHandler) {\n      const set = this.handlers.get(event) ?? new Set();\n      set.add(handler);\n      this.handlers.set(event, set);\n    }\n    off(event: string, handler?: EventHandler) {\n      if (!this.handlers.has(event)) return;\n      if (!handler) { this.handlers.delete(event); return; }\n      this.handlers.get(event)!.delete(handler);\n    }\n\n    private emit(event: string, payload?: any) {\n      const set = this.handlers.get(event);\n      if (!set) return;\n      for (const cb of Array.from(set)) cb(payload);\n    }\n\n    async connectFeed(adapter: any): Promise<void> {\n      if (!this.core) throw new Error('Chart not created');\n      await this.core.connectFeed(adapter);\n    }\n    async disconnectFeed(): Promise<void> {\n      if (!this.core) return;\n      await this.core.disconnectFeed();\n    }\n\n    async destroy(): Promise<void> {\n      // detach events\n      const canvas = this.getCanvas();\n      const l = (this as any)._listeners;\n      if (canvas && l) {\n        canvas.removeEventListener('pointerdown', l.onPointerDown);\n        canvas.removeEventListener('pointermove', l.onPointerMove);\n        window.removeEventListener('pointerup', l.onPointerUp);\n        canvas.removeEventListener('wheel', l.onWheel as EventListener);\n        canvas.removeEventListener('touchstart', l.onTouchStart as EventListener);\n        canvas.removeEventListener('touchmove', l.onTouchMove as EventListener);\n        canvas.removeEventListener('touchend', l.onTouchEnd as EventListener);\n      }\n      if (this.tooltipEl && this.tooltipEl.parentElement) this.tooltipEl.parentElement.removeChild(this.tooltipEl);\n      if (this.legendEl && this.legendEl.parentElement) this.legendEl.parentElement.removeChild(this.legendEl);\n      if (this.core) await this.core.destroy();\n      this.handlers.clear();\n      this.core = null; this.container = null; this.tooltipEl = null;\n    }\n\n    // public convenience methods\n    setViewport(from: number, to: number) { this.core?.setViewport(from, to); }\n    panBy(deltaIndex: number) { this.core?.panBy(deltaIndex); }\n    zoomAt(factor: number, centerIndex?: number) { this.core?.zoomAt(factor, centerIndex); }\n    attach(container: HTMLElement) { this.container = container; }\n    detach() { /* no-op: events removal in destroy */ }\n  }\n\n  return new ChartEmbed();\n}\n",
    "export { createEmbedAPI } from './core/embedApi';\nexport { ChartCore } from './core/chart';\n\n// Export embed API types\nexport type { ChartEmbedAPI, EventHandler } from './core/embedApi';\n// Convenience default export\nexport default {\n  createEmbedAPI: (await import('./core/embedApi')).createEmbedAPI\n};\nexport { MoChart } from './core/chart';\nexport type { ChartConfig, ChartOptions, OhlcvPoint, IndicatorInstance } from './core/types';\nexport type {\n\tIndicatorDefinition,\n\tIndicatorError,\n\tIndicatorParamSchema,\n\tIndicatorResult,\n\tIndicatorValue,\n\tMultiSeriesOutput,\n\tPlotPane,\n\tPlotStyle,\n\tSeriesStyle,\n} from './core/indicatorTypes';\nexport type { TradeMarker, TradeMarkerType } from './core/tradeMarkers';\nexport { DEFAULT_MARKER_STYLES } from './core/tradeMarkers';\nexport { INDICATOR_I18N, t } from './core/i18n';\nexport { INDICATOR_PHASES } from './core/indicatorCatalog';\nexport {\n\tBollingerBands,\n\tEMA,\n\tPhase1Indicators,\n\tPivotPoints,\n\tSMA,\n\tVolume,\n\tregisterPhase1Indicators,\n} from './indicators/phase1';\nexport {\n\tBBWidth,\n\tPercentB,\n\tPhase3Indicators,\n\tVWAP,\n\tVolRatio,\n\tregisterPhase3Indicators,\n} from './indicators/phase3';\nexport {\n\tADX,\n\tATR,\n\tMACD,\n\tPhase2Indicators,\n\tRSI,\n\tTradeMarkers,\n\tregisterPhase2Indicators,\n} from './indicators/phase2';\nexport {\n\tCMF,\n\tDivergence,\n\tMFI,\n\tOBV,\n\tKaufmanPatterns,\n\tPhase4Indicators,\n\tSqueezeAlert,\n\tregisterPhase4Indicators,\n} from './indicators/phase4';\nexport { InMemoryIndicatorRegistry } from './core/indicators';\n",
    "export type I18nStrings = Record<string, { en: string; ja: string }>;\n\nexport const INDICATOR_I18N: I18nStrings = {\n  'indicator.bb.name': { en: 'Bollinger Bands', ja: 'ボリンジャーバンド' },\n  'indicator.rsi.name': { en: 'RSI', ja: 'RSI（相対力指数）' },\n  'indicator.adx.name': { en: 'ADX', ja: 'ADX（平均方向性指数）' },\n  'indicator.macd.name': { en: 'MACD', ja: 'MACD' },\n  'indicator.atr.name': { en: 'ATR', ja: 'ATR' },\n  'indicator.volume.name': { en: 'Volume', ja: '出来高' },\n};\n\nexport const t = (key: string, locale: 'en' | 'ja' = 'ja'): string => {\n  return INDICATOR_I18N[key]?.[locale] ?? key;\n};\n",
    "export type IndicatorPhase = 'phase1' | 'phase2' | 'phase3' | 'phase4';\n\nexport const INDICATOR_PHASES: Record<IndicatorPhase, string[]> = {\n  phase1: ['volume', 'sma', 'ema', 'bb', 'candles'],\n  phase2: ['rsi', 'adx', 'atr', 'macd', 'trade_markers'],\n  phase3: ['vwap', 'vol_ratio', 'percent_b', 'bb_width'],\n  phase4: ['obv', 'cmf', 'mfi', 'kaufman_patterns'],\n};\n"
  ],
  "mappings": "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",
  "debugId": "9FD754954A314A7564756E2164756E21",
  "names": []
}