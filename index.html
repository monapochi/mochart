<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>prototype</title>
  <style media="screen">
    div.chart {
      position: relative;
    }
    
    div.chart .overlay {
      display: none;
      position: absolute;
      left: 10px;
      top: 10px;
    }

    canvas.glcanvas {
      width: 100vw;
      height: 95vh;
      margin: 0;
      padding: 0;
    }

    input {
      width: 100vw;
      height: 5vh;
      margin: 0;
      padding: 0;
    }
  </style>
</head>

<body>
  <div class="chart">
    <canvas class="glcanvas"></canvas>
    
    
    
    <script type="module">
      // Inline Canvas demo with visible window, axes and scaling
      function niceStep(range, targetTicks) {
        const raw = range / targetTicks;
        const pow = Math.pow(10, Math.floor(Math.log10(raw)));
        const r = raw / pow;
        const nice = r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10;
        return nice * pow;
      }

      function formatPrice(v) {
        const abs = Math.abs(v);
        const digits = abs < 1 ? 4 : abs < 10 ? 3 : abs < 100 ? 2 : 2;
        return v.toLocaleString(undefined, { maximumFractionDigits: digits });
      }

      function drawCandles(canvas, data, opts = {}) {
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const w = canvas.clientWidth || 800;
        const h = canvas.clientHeight || 600;
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // layout
        const gutterLeft = opts.yAxisGutterPx ?? 56;
        const gutterRight = 8;
        const gutterTop = 8;
        const xAxisHeight = opts.xAxisHeightPx ?? 26;
        const plotX = gutterLeft;
        const plotY = gutterTop;
        const plotW = w - gutterLeft - gutterRight;
        const plotH = h - gutterTop - xAxisHeight - 6;

        // visible window: last N bars
        const maxVisible = opts.maxVisibleBars ?? 200;
        const visibleCount = Math.min(maxVisible, data.length);
        const start = Math.max(0, data.length - visibleCount);
        const end = data.length - 1;
        const visible = data.slice(start, end + 1);

        // compute visible price range
        let min = Infinity, max = -Infinity;
        for (const d of visible) { if (d.low < min) min = d.low; if (d.high > max) max = d.high; }
        if (!isFinite(min) || !isFinite(max)) return;
        const padRatio = opts.paddingRatio ?? 0.05;
        const pad = (max - min) * padRatio;
        const yMin = min - Math.max(pad, opts.minPaddingPx ?? 6);
        const yMax = max + Math.max(pad, opts.minPaddingPx ?? 6);

        const priceToY = (p) => {
          const t = (p - yMin) / (yMax - yMin || 1);
          return plotY + (1 - t) * plotH;
        };

        // clear background
        ctx.fillStyle = opts.background ?? '#ffffff';
        ctx.fillRect(0, 0, w, h);

        // No data fallback: show centered message
        if (!data || !Array.isArray(data) || data.length === 0) {
          ctx.fillStyle = opts.noDataColor ?? '#666666';
          ctx.font = opts.noDataFont ?? '20px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const msg = opts.noDataText ?? 'No Data';
          ctx.fillText(msg, w / 2, h / 2);
          return;
        }

        // Y ticks (nice numbers)
        const targetYTicks = opts.targetYTicks ?? 5;
        const step = niceStep(yMax - yMin, targetYTicks);
        const firstTick = Math.ceil(yMin / step) * step;
        const ticks = [];
        for (let v = firstTick; v <= yMax + 1e-12; v += step) ticks.push(v);

        // draw grid and Y labels
        ctx.font = opts.font ?? '12px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = opts.axisLabelColor ?? '#222222';
        ctx.strokeStyle = opts.gridColor ?? '#e6e6e6';
        ctx.lineWidth = 1;
        for (const t of ticks) {
          const y = priceToY(t);
          // grid
          ctx.beginPath();
          ctx.moveTo(plotX, y);
          ctx.lineTo(plotX + plotW, y);
          ctx.stroke();
          // label
          ctx.fillStyle = opts.axisLabelColor ?? '#222222';
          ctx.fillText(formatPrice(t), plotX - 8, y);
        }

        // draw Y axis line
        ctx.strokeStyle = opts.axisLabelColor ?? '#222222';
        ctx.beginPath(); ctx.moveTo(plotX, plotY); ctx.lineTo(plotX, plotY + plotH); ctx.stroke();

        // X ticks: choose approx targetXTicks
        const targetXTicks = opts.targetXTicks ?? 6;
        const visibleFromTime = visible[0].time;
        const visibleToTime = visible[visible.length - 1].time;
        const spanMs = visibleToTime - visibleFromTime || 1;
        const approxInterval = spanMs / (targetXTicks - 1);
        // simple strategy: pick evenly spaced indices
        const xTicks = [];
        for (let i = 0; i < targetXTicks; i++) {
          const frac = i / (targetXTicks - 1);
          const idx = Math.round(frac * (visible.length - 1));
          xTicks.push({ time: visible[idx].time, idx: start + idx });
        }

        // draw candles
        const stepX = plotW / Math.max(1, visible.length - 1);
        const candleW = Math.max(2, Math.min(Math.floor(stepX * 0.7), 40));
        const outlineColor = opts.outlineColor || '#222222';
        const wickColor = opts.wickColor || outlineColor;
        const upColor = opts.upColor || '#2e7d32';
        const downColor = opts.downColor || '#d32f2f';

        // clip to plot area
        ctx.save();
        ctx.beginPath();
        ctx.rect(plotX, plotY, plotW, plotH);
        async function initDemo() {
          const canvas = document.querySelector('div.chart .glcanvas');
          if (!canvas) return;
          // load data via fetch only (avoid browser dynamic-import/json MIME issues)
          let data;
          try {
            const resp = await fetch('./fixtures/MSFT.json?_=' + Date.now());
            const ct = resp.headers.get('content-type') || '';
            if (ct.includes('application/json')) data = await resp.json();
            else { const txt = await resp.text(); data = JSON.parse(txt); }
          } catch (e) {
            console.error('Failed to load MSFT fixture', e);
            data = [];
          }
          if (!data || !Array.isArray(data)) data = [];
            try {
              const apiMod = await import('./dist/src/core/embedApi.js');
              const embed = apiMod.createEmbedAPI();
              const container = document.querySelector('div.chart');
              const core = await embed.create(container, { enableTooltip: true, showLegend: true, symbol: 'MSFT' });
              const seriesId = await core.addSeries({ id: 'msft', type: 'candlestick', name: 'MSFT', upColor: '#2e7d32', downColor: '#d32f2f', outlineColor: '#222222' });
              await core.setSeriesData(seriesId, data || []);
              // expose embed API and core for debugging
              window.__demoEmbed = embed;
              window.__demoChartCore = core;
            } catch (e) {
              console.error('Failed to initialize embed API demo', e);
            }
        }

        // initial run
        initDemo();

        // HMR: accept updates and re-run init to avoid full page reloads
        if (import.meta.hot) {
          import.meta.hot.accept(() => {
            try { initDemo(); } catch (e) { console.error('HMR init failed', e); }
          });
        }

        for (let i = 0; i < visible.length; i++) {
          const d = visible[i];
          const x = plotX + i * stepX;
          const yOpen = priceToY(d.open);
          const yClose = priceToY(d.close);
          const yHigh = priceToY(d.high);
          const yLow = priceToY(d.low);
          const top = Math.min(yOpen, yClose);
          const bottom = Math.max(yOpen, yClose);

          // wick
          ctx.strokeStyle = wickColor; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(x + 0.5, yHigh); ctx.lineTo(x + 0.5, yLow); ctx.stroke();

          // body
          if (d.close > d.open) {
            ctx.fillStyle = upColor;
            ctx.fillRect(x - candleW/2, top, candleW, Math.max(1, bottom - top));
            ctx.strokeStyle = outlineColor; ctx.lineWidth = 1; ctx.strokeRect(x - candleW/2, top, candleW, Math.max(1, bottom - top));
          } else if (d.close < d.open) {
            ctx.fillStyle = downColor;
            ctx.fillRect(x - candleW/2, top, candleW, Math.max(1, bottom - top));
            ctx.strokeStyle = outlineColor; ctx.lineWidth = 1; ctx.strokeRect(x - candleW/2, top, candleW, Math.max(1, bottom - top));
          } else {
            // equal -> crosshair
            const cy = (yOpen + yClose) / 2;
            const hx = candleW * 0.9;
            ctx.strokeStyle = outlineColor; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(x - hx/2, cy); ctx.lineTo(x + hx/2, cy); ctx.moveTo(x, cy - hx/2); ctx.lineTo(x, cy + hx/2); ctx.stroke();
          }
        }
        ctx.restore();

        // draw X axis ticks and labels
        const dateFormat = (t) => {
          const dt = new Date(t);
          if (spanMs > 365 * 24 * 3600 * 1000) return dt.toLocaleDateString();
          if (spanMs > 7 * 24 * 3600 * 1000) return dt.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
          return dt.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        };

        ctx.fillStyle = opts.axisLabelColor ?? '#222222';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.font = opts.font ?? '12px sans-serif';
        for (const t of xTicks) {
          const localIdx = t.idx - start;
          const x = plotX + localIdx * stepX;
          // tick
          ctx.beginPath(); ctx.moveTo(x + 0.5, plotY + plotH); ctx.lineTo(x + 0.5, plotY + plotH + 6); ctx.stroke();
          // label
          ctx.fillText(dateFormat(t.time), x, plotY + plotH + 4 + 2);
        }

        // draw X axis baseline
        ctx.strokeStyle = opts.axisLabelColor ?? '#222222';
        ctx.beginPath(); ctx.moveTo(plotX, plotY + plotH); ctx.lineTo(plotX + plotW, plotY + plotH); ctx.stroke();
      }

      // Controller with interactions and tooltip
      class ChartView {
        constructor(canvas, data, opts = {}) {
          this.canvas = canvas;
          this.data = data;
          this.opts = Object.assign({}, opts);
          this.start = Math.max(0, data.length - (opts.maxVisibleBars ?? 200));
          this.visibleCount = Math.min(opts.maxVisibleBars ?? 200, data.length);
          this.dragging = false;
          this.dragStartX = 0;
          this.dragStartIndex = this.start;
          this.enableTooltip = !!opts.enableTooltip;
          this.tooltip = null;
          this._bindEvents();
          this.draw();
        }

        setTooltipEnabled(v) { this.enableTooltip = !!v; if (!this.enableTooltip && this.tooltip) this.tooltip.style.display = 'none'; }

        _makeTooltip() {
          if (this.tooltip) return this.tooltip;
          const div = document.createElement('div');
          div.style.position = 'absolute';
          div.style.pointerEvents = 'none';
          div.style.background = 'rgba(0,0,0,0.8)';
          div.style.color = '#fff';
          div.style.padding = '6px 8px';
          div.style.borderRadius = '4px';
          div.style.font = '12px sans-serif';
          div.style.display = 'none';
          div.style.zIndex = '1000';
          this.canvas.parentElement.appendChild(div);
          this.tooltip = div;
          return div;
        }

        _bindEvents() {
          const c = this.canvas;
          c.addEventListener('mousedown', (e) => {
            this.dragging = true; this.dragStartX = e.clientX; this.dragStartIndex = this.start;
          });
          window.addEventListener('mouseup', () => { this.dragging = false; });
          c.addEventListener('mousemove', (e) => {
            if (this.dragging) {
              const rect = this.canvas.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const w = this.canvas.clientWidth || 800;
              const gutterLeft = this.opts.yAxisGutterPx ?? 56;
              const plotW = w - gutterLeft - (this.opts.yAxisGutterPx ? 8 : 8);
              const stepX = plotW / Math.max(1, this.visibleCount - 1);
              const dx = e.clientX - this.dragStartX;
              const deltaIndex = Math.round(-dx / stepX);
              this.start = Math.min(Math.max(0, this.dragStartIndex + deltaIndex), Math.max(0, this.data.length - this.visibleCount));
              this.draw();
              return;
            }
            // hover
            if (this.enableTooltip) this._showHover(e);
          });
          c.addEventListener('mouseleave', () => { if (this.tooltip) this.tooltip.style.display = 'none'; });
          c.addEventListener('wheel', (ev) => {
            ev.preventDefault();
            const delta = ev.deltaY < 0 ? 1 / 1.15 : 1.15;
            // zoom centered on cursor
            const rect = this.canvas.getBoundingClientRect();
            const cx = ev.clientX - rect.left;
            const w = this.canvas.clientWidth || 800;
            const gutterLeft = this.opts.yAxisGutterPx ?? 56;
            const plotW = w - gutterLeft - 8;
            const rel = Math.max(0, Math.min(1, (cx - gutterLeft) / plotW));
            const centerIndex = this.start + Math.round(rel * (this.visibleCount - 1));
            let newCount = Math.max(5, Math.min(this.data.length, Math.round(this.visibleCount * delta)));
            newCount = Math.min(this.data.length, Math.max(5, newCount));
            // keep centerIndex roughly centered
            let newStart = centerIndex - Math.round(rel * (newCount - 1));
            newStart = Math.max(0, Math.min(this.data.length - newCount, newStart));
            this.visibleCount = newCount; this.start = newStart; this.draw();
          }, { passive: false });
        }

        _showHover(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const w = this.canvas.clientWidth || 800;
          const gutterLeft = this.opts.yAxisGutterPx ?? 56;
          const plotW = w - gutterLeft - 8;
          const stepX = plotW / Math.max(1, this.visibleCount - 1);
          const localX = x - gutterLeft;
          if (localX < -10 || localX > plotW + 10) { if (this.tooltip) this.tooltip.style.display = 'none'; return; }
          const idx = Math.round(localX / stepX);
          const dataIdx = this.start + Math.max(0, Math.min(this.visibleCount - 1, idx));
          const d = this.data[dataIdx];
          if (!d) { if (this.tooltip) this.tooltip.style.display = 'none'; return; }
          const tooltip = this._makeTooltip();
          tooltip.innerHTML = `<div><strong>${new Date(d.time).toLocaleDateString()}</strong></div><div>O ${d.open} H ${d.high}</div><div>L ${d.low} C ${d.close}</div><div>V ${d.volume.toLocaleString()}</div>`;
          tooltip.style.left = Math.max(6, e.clientX - rect.left + 12) + 'px';
          tooltip.style.top = Math.max(6, e.clientY - rect.top + 12) + 'px';
          tooltip.style.display = 'block';
        }

        draw() {
          drawCandles(this.canvas, this.data, Object.assign({}, this.opts, { startIndex: this.start, visibleCount: this.visibleCount }));
        }
      }

      async function runDiagnostics() {
        const urls = ['./fixtures/MSFT.json', './src/core/embedApi.ts'];
        const results = [];
        for (const u of urls) {
          try {
            const resp = await fetch(u + '?_diag=' + Date.now(), { cache: 'no-store' });
            const ct = resp.headers.get('content-type') || '';
            const status = resp.status;
            const txt = await resp.text();
            const snippet = txt.slice(0, 200);
            console.log('[DIAG]', u, status, ct, snippet.startsWith('<') ? '(starts with <)' : snippet.slice(0, 120));
            results.push({ url: u, status, contentType: ct, snippet });
          } catch (e) {
            console.error('[DIAG] fetch error', u, e);
            results.push({ url: u, error: String(e) });
          }
        }
        const overlayId = '__mochart_diag_overlay';
        /** @type {HTMLDivElement|null} */
        let overlay = document.getElementById(overlayId);
        if (!overlay) {
          overlay = document.createElement('div');
          overlay.id = overlayId;
          overlay.style.position = 'fixed';
          overlay.style.right = '8px';
          overlay.style.bottom = '8px';
          overlay.style.maxWidth = '46vw';
          overlay.style.maxHeight = '48vh';
          overlay.style.overflow = 'auto';
          overlay.style.background = 'rgba(0,0,0,0.85)';
          overlay.style.color = '#fff';
          overlay.style.font = '12px monospace';
          overlay.style.padding = '8px';
          overlay.style.zIndex = '10000';
          overlay.style.whiteSpace = 'pre-wrap';
          document.body.appendChild(overlay);
        }
        overlay.textContent = results.map(r => {
          if (r && r.error) return `${r.url} -> ERROR: ${r.error}`;
          return `${r.url} -> ${r.status} ${r.contentType}\n${(r.snippet||'').replace(/\n/g,'\\n')}`;
        }).join('\n\n---\n\n');
        return results;
      }

      window.addEventListener('load', async () => {
        // run diagnostics first
        try { await runDiagnostics(); } catch (e) { console.error('Diagnostics failed', e); }
        const canvas = document.querySelector('div.chart .glcanvas');
        if (!canvas) return;
        try {
          // Try relative fetch first so Bun's dev server serves the JSON asset.
          const resp = await fetch('./fixtures/MSFT.json');
          let data;
          try {
            // prefer JSON; if server returned HTML (SPA fallback), try to detect and fail gracefully
            const ct = resp.headers.get('content-type') || '';
            if (ct.includes('application/json')) {
              data = await resp.json();
            } else {
              const txt = await resp.text();
              try { data = JSON.parse(txt); }
              catch (e) { throw new Error('Failed to load MSFT fixture: response not JSON'); }
            }
          } catch (e) {
            console.error('Failed to parse MSFT fixture', e, resp && resp.status);
            data = [];
          }
          if (!data || !Array.isArray(data)) data = [];
          try {
            const apiMod = await import('./dist/src/core/embedApi.js');
            const embed = apiMod.createEmbedAPI();
            const container = document.querySelector('div.chart');
            const core = await embed.create(container, { enableTooltip: true, showLegend: true, symbol: 'MSFT' });
            const seriesId = await core.addSeries({ id: 'msft', type: 'candlestick', name: 'MSFT', upColor: '#2e7d32', downColor: '#d32f2f', outlineColor: '#222222' });
            await core.setSeriesData(seriesId, data || []);
            window.__demoEmbed = embed;
            window.__demoChartCore = core;
          } catch (e) {
            console.error('Failed to initialize embed API demo', e);
          }
        } catch (e) {
          console.error('Failed to load MSFT fixture', e);
        }
      });
    </script>
  </div>

  <div id="viewport"></div>
</body>

</html>